<?xml version="1.0" encoding="UTF-8"?>
<commandline xmlns:xi='http://www.w3.org/2001/XInclude'>
   %prog command [subcommand] options
   <command name="*">
      <optgroup name="all commands">
         <!-- Note: "verbose" and "quiet" are handled specially in the code; do not
              use "conflicts" here -->
         <option name="verbose" short="v" type="flag" default="True">
            Verbose mode.  Contact the broker for out of band status messages
            about the request while it is being processed.  These messages
            are printed on stderr.
         </option>
         <option name="quiet" short="q" type="flag">
            Turn off verbose mode.  Do not make a secondary request to
            the broker for out of band status messages.
         </option>
         <option name="partialok" type="boolean" conflicts="">
            For any command that returns status 207 (MULTI_STATUS) indicating
            some success and some failure, exit with status code 0 instead of
            exit code 2.  Warning messages will still go to stderr.
         </option>
         <option name="debug" short="d" type="boolean" conflicts="">
            Generate debug statements sent to stderr.  Some commands may
            also increase output from the server on stdout.
         </option>
         <option name="httpinfo" short="u" type="boolean" conflicts="">
            Show the URL being accessed and the response code.
            Implied by --debug.
         </option>
         <option name="format" short="f" type="string" conflicts="">
            Specify output format as raw (default) or html.
         </option>
         <option name="auth" type="boolean" conflicts="usesock" default="True">
            Connect to aqport using knc for authentication.
         </option>
         <option name="exec" type="boolean" default="True">
            Run any commands that the server sends back.
         </option>
         <option name="usesock" type="string" conflicts="noauth">
            Connect directly (noauth) to the given unix socket.
         </option>
         <option name="slowstatus" type="boolean" conflicts="quiet">
            Request status messages from the server only after the
            original request completes.  This is only meant to be used
            for aqd development with a broker running with a sqlite database.
         </option>
         <option name="aqport" type="int" conflicts="">
            Server port to connect to.
         </option>
         <option name="aqhost" type="string" conflicts="">
            Name of the server to connect to.
         </option>
         <option name="aquser" type="string" conflicts="aqservice">
            [Deprecated] Name of the kerberos service principal to authenticate to the server.
            Use aqservice instead.
         </option>
         <option name="aqservice" type="string" conflicts="aquser">
            Name of the kerberos service principal to authenticate to the server.
            Should default correctly, only useful for development.
         </option>
      </optgroup>
   </command>

   <command name="status">
      Shows the current server status.
      <transport method="get" path="" />
   </command>

   <command name="flush">
      Force the server to (re)write the plenary templates
      based on the current information in AQDB. This is intended to
      be used when re-creating the server state after a rebuild, or
      when upgrading the broker.
      <p/>
      Requires aqd_admin entitlement.
      <p/>
      Without arguments, no templates are selected for flushing. Use
      either --all to select all templates, or specify which groups
      of templates to flush by combining arguments. For example, "flush
      --hosts --machines" would flush all the host and machine templates
      but would leave all other plenary templates alone.
      <p/>
      The command will return success if all templates selected were
      written without error. The command will return partial success if
      any templates could not be written. The output of the command indicates
      how many templates were successfully written and how many templates
      were selected. For example "flushed 10/10 templates" would indicate
      that 10 templates matched and they were all written out successfully.
      <optgroup name="sections" fields="any">
         <option name="hosts" type="boolean">flush the host templates</option>
         <option name="machines" type="boolean">flush the machine templates</option>
         <option name="personalities" type="boolean">flush the personality templates</option>
         <option name="clusters" type="boolean">flush the cluster templates</option>
         <option name="services" type="boolean">flush the service templates</option>
         <option name="resources" type="boolean">flush the resource templates</option>
         <option name="locations" type="boolean">flush templates related to locations. This is only cities for now.</option>
         <option name="all" type="flag">flush all templates</option>
      </optgroup>
      <transport method="post" path="flush" />
   </command>

   <command name="ping">
      Simple test that the broker can respond.
      <transport method="get" path="ping" />
   </command>

   <command name="show_active_commands">
      Show any active commands currently running on the broker.
      <p/>
      In this version, the command does not make a database connection
      and relies on in memory knowledge of running commands.  This
      behavior may change in a future version.
      <transport method="get" path="active_commands" />
   </command>

   <command name="show_active_locks">
      Show any active locks currently held by broker commands.
      <p/>
      In this version, the command does not make a database connection
      and relies on in memory knowledge of acquired locks.  This
      behavior may change in a future version.
      <transport method="get" path="active_locks" />
   </command>

   <command name="show_request">
      Show any status messages for the given request.
      <p/>
      The request can be identified by either the request id generated by
      the client when a request is initiated or by the audit id generated
      by the server when a request comes in.
      <optgroup name="show_request_mandatory" mandatory="True" fields="any">
         <option name="requestid" type="string" conflicts="auditid">Client-created Request ID</option>
         <option name="auditid" type="string" conflicts="requestid">Server-created Audit ID</option>
      </optgroup>
      <transport method="get" path="status/requestid/%(requestid)s" />
      <transport method="get" trigger="auditid" path="status/auditid/%(auditid)s" />
   </command>

   <command name="show_host">
      Shows the complete configuration for a given host. If the '--all' option
      is provided, then the command simply outputs a listing of all known hostnames.
      <optgroup name="show_host_Input" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="all">Host name</option>
         <option name="all" type="flag" conflicts="hostname">Select all hosts</option>
      </optgroup>
      <transport trigger="all" method="get" path="host" />
      <transport trigger="hostname" method="get" path="host/%(hostname)s" />
   </command>

   <command name="show_fqdn">
      This command is deprecated.  Please use search_dns instead.
      <p/>
      Shows any information available for the fqdn.  This could be a host,
      a top of rack switch, a chassis, or any other system tracked by
      AQDB.
      <optgroup name="show_fqdn_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string" conflicts="all">full qualified domain name</option>
         <option name="all" type="flag" conflicts="fqdn">select all systems</option>
      </optgroup>
      <optgroup name="show_fqdn_options" mandatory="False" fields="any">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport trigger="all" method="get" path="system" />
      <transport trigger="fqdn" method="get" path="system/%(fqdn)s" />
   </command>

   <command name="search_hardware">
      Shows any information available for the matching hardware.  These
      could be machines, top of rack switches, chassis, or any other hardware
      tracked by AQDB.
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --exact_location option can be used to override this behavior.
      <optgroup name="search_hardware_opts" mandatory="True" fields="any">
         <option name="model" type="string">model name</option>
         <option name="machine_type" type="string">machine type for the model (blade, virtual_machine, etc.)</option>
         <option name="vendor" type="string">vendor name</option>
         <option name="mac" type="mac">MAC address of an attached interface</option>
         <option name="pg" type="string">port group of an attached interface</option>
         <option name="interface_model" type="string">Having an interface of the given model</option>
         <option name="interface_vendor" type="string">Having an interface of the given vendor</option>
         <option name="serial" type="string">serial number</option>
         <optgroup name="search_hardware_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="exact_location" type="flag">match the location exactly</option>
         <option name="all" type="flag">list all hardware</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="fullinfo" type="flag">show full information for the matching hardware</option>
      </optgroup>
      <transport method="get" path="find/hardware" />
   </command>

   <command name="search_machine">
      Shows any information available for machine hardware.
      <p/>
      (See search_hardware for a more general hardware search.)
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --exact_location option can be used to override this behavior.
      <optgroup name="search_machine_opts" mandatory="True" fields="any">
         <option name="machine" type="string">machine name (exact)</option>
         <option name="cpuname" type="string">cpu name</option>
         <option name="cpuvendor" type="string">cpu vendor</option>
         <option name="cpuspeed" type="int">cpu speed</option>
         <option name="cpucount" type="int">cpu count</option>
         <option name="memory" type="int">memory in MB</option>
         <option name="cluster" type="string">cluster name</option>
         <option name="model" type="string">model name</option>
         <option name="machine_type" type="string">machine type for the model (blade, virtual_machine, etc.)</option>
         <option name="vendor" type="string">vendor name</option>
         <option name="mac" type="mac">MAC address of an attached interface</option>
         <option name="interface_model" type="string">Having an interface of the given model</option>
         <option name="interface_vendor" type="string">Having an interface of the given vendor</option>
         <option name="pg" type="string">port group of an attached interface</option>
         <option name="serial" type="string">serial number</option>
         <option name="share" type="string">nas_disk_share in use by a virtual machine</option>
         <optgroup name="search_machine_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="exact_location" type="flag">match the location exactly</option>
         <option name="all" type="flag">list all hardware</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="fullinfo" type="flag">show full information for the machine</option>
      </optgroup>
      <transport method="get" path="find/machine" />
   </command>

   <command name="search_system">
      Shows any information available for the matching systems.  These
      could be hosts, top of rack switches, chassis, or any other system
      tracked by AQDB.
      <optgroup name="search_system_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string">fully qualified domain name</option>
         <option name="dns_domain" type="string">DNS domain</option>
         <option name="shortname" type="string">First segment of the fqdn</option>
         <option name="type" type="string">System type (host, chassis, switch, manager, auxiliary)</option>
         <option name="ip" type="ipv4">IP address</option>
         <option name="networkip" type="ipv4">Network IP address</option>
         <option name="mac" type="mac">primary MAC address</option>
         <option name="all" type="flag">list all systems</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="fullinfo" type="flag">show full information for the matching systems</option>
      </optgroup>
      <transport method="get" path="find/system" />
   </command>

   <command name="search_cluster">
      Shows any information available for the matching clusters.
      <p/>
      <optgroup name="search_cluster_opts" mandatory="True" fields="any">
         <option name="archetype" type="string">archetype (aquilon, windows, aurora)</option>
         <option name="buildstatus" type="string">buildstatus (blind, build, ready)</option>
         <option name="cluster_type" type="string">cluster type of archetype (compute)</option>
         <option name="personality" type="string">personality</option>
         <option name="allowed_archetype" type="string">allowed_archetype</option>
         <option name="allowed_personality" type="string">allowed_personality</option>
         <option name="down_hosts_threshold" type="string">down_hosts_threshold</option>
         <option name="down_maint_threshold" type="string">down_maint_threshold</option>
         <option name="max_members" type="int">max_members</option>
         <option name="member_archetype" type="string">member_archetype</option>
         <option name="member_hostname" type="string">member_hostname</option>
         <option name="member_personality" type="string">member_personality</option>
         <optgroup name="search_cluster_branch" fields="any">
            <option name="domain" type="string" conflicts="sandbox branch">template domain</option>
            <option name="sandbox" type="string" conflicts="domain branch">Name of the sandbox (given as 'author/branch')</option>
            <option name="branch" type="string" conflicts="domain sandbox">template branch (either a domain or a sandbox)</option>
         </optgroup>
         <optgroup name="search_esx_opts" fields="any">
           <option name="cluster" type="string">cluster name</option>
           <option name="esx_metacluster" type="string">metacluster name</option>
           <option name="esx_virtual_machine" type="string">virtual machine label (evm1)</option>
           <option name="esx_guest" type="string">fully qualified host name of a virtual machine</option>
           <option name="service" type="string">client of service (single service only)</option>
           <option name="instance" type="string">client of service instance (single instance only)</option>
           <option name="esx_share" type="string">nas_disk_share in use by an virtual machine on the cluster</option>
           <option name="capacity_override" type="flag">Select clusters with capacity overrides</option>
           <option name="esx_switch" type="string">Select clusters bound to the given switch</option>
         </optgroup>
         <optgroup name="search_cluster_location_opts" fields="any">
            <option name="cluster_organization" type="string">Cluster Organization</option>
            <option name="cluster_hub" type="string">Cluster Hub</option>
            <option name="cluster_continent" type="string">Cluster Continent</option>
            <option name="cluster_country" type="string">Cluster Country</option>
            <option name="cluster_campus" type="string">Cluster Campus</option>
            <option name="cluster_city" type="string">Cluster City</option>
            <option name="cluster_building" type="string">Cluster Building</option>
            <option name="cluster_room" type="string">Cluster Room</option>
            <option name="cluster_rack" type="string">Cluster Rack</option>
            <option name="cluster_desk" type="string">Cluster Desk</option>
         </optgroup>
         <option name="cluster_exact_location" type="flag">match the cluster location exactly</option>
         <optgroup name="search_vmhost_location_opts" fields="any">
            <option name="member_organization" type="string">member Organization</option>
            <option name="member_hub" type="string">member Hub</option>
            <option name="member_continent" type="string">member Continent</option>
            <option name="member_country" type="string">member Country</option>
            <option name="member_campus" type="string">member Campus</option>
            <option name="member_city" type="string">member City</option>
            <option name="member_building" type="string">member Building</option>
            <option name="member_room" type="string">member Room</option>
            <option name="member_rack" type="string">member Rack</option>
            <option name="member_desk" type="string">member Desk</option>
         </optgroup>
         <option name="member_exact_location" type="flag">match the member location exactly</option>
         <option name="all" type="flag">list all systems</option>
      </optgroup>
      <optgroup name="search_cluster_prefs" mandatory="False">
         <option name="fullinfo" type="flag">show full information for the matching hosts</option>
      </optgroup>
      <transport method="get" path="find/cluster" />
   </command>

   <command name="search_host">
      Shows any information available for the matching hosts.
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --exact_location option can be used to override this behavior.
      <optgroup name="search_host_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">fully qualified domain name</option>
         <option name="machine" type="string">node name</option>
         <option name="dns_domain" type="string">DNS domain</option>
         <option name="shortname" type="string">First segment of the fqdn</option>
         <option name="archetype" type="string">archetype (aquilon, windows, aurora)</option>
         <option name="buildstatus" type="string">buildstatus (blind, build, ready)</option>
         <option name="ip" type="ipv4">IP address</option>
         <option name="networkip" type="ipv4">Network IP address</option>
         <option name="network_environment" type="string">Network environment (default: internal)</option>
         <option name="mac" type="mac">primary MAC address</option>
         <option name="personality" type="string">personality</option>
         <option name="osname" type="string">osname</option>
         <option name="osversion" type="string">osversion</option>
         <option name="service" type="string">client of service (single service only)</option>
         <option name="instance" type="string">client of service instance (single instance only)</option>
         <option name="model" type="string">machine model name</option>
         <option name="machine_type" type="string">machine type for the model (blade, virtual_machine, etc.)</option>
         <option name="vendor" type="string">machine vendor name</option>
         <option name="serial" type="string">machine serial number</option>
         <option name="cluster" type="string">cluster name</option>
         <option name="guest_on_cluster" type="string">host is a virtual machine guest on this cluster</option>
         <option name="guest_on_share" type="string">host is a virtual machine using this nas_disk_share</option>
         <option name="member_cluster_share" type="string">host is a member of a cluster with machines using this nas_disk_share</option>
         <optgroup name="search_host_branch" fields="any">
            <option name="domain" type="string" conflicts="sandbox branch">template domain</option>
            <option name="sandbox" type="string" conflicts="domain branch">Name of the sandbox (given as 'author/branch')</option>
            <option name="branch" type="string" conflicts="domain sandbox">template branch (either a domain or a sandbox)</option>
         </optgroup>
         <optgroup name="search_host_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="server_of_service" type="string">server of service (single service only)</option>
         <option name="server_of_instance" type="string">server of service instance (single instance only)</option>
         <option name="exact_location" type="flag">match the location exactly</option>
         <option name="grn" type="string">match by GRN</option>
         <option name="eon_id" type="int">match by EON ID</option>
         <option name="all" type="flag">list all systems</option>
      </optgroup>
      <optgroup name="search_host_prefs" mandatory="False">
         <option name="fullinfo" type="flag">show full information for the matching hosts</option>
      </optgroup>
      <transport method="get" path="find/host" />
   </command>

   <command name="search_esx_cluster">
      Shows any information available for the matching ESX clusters.
      <p/>
      There are three sets of parameters: 1 - those that match directly
      against the cluster (name, domain, cluster_building, etc.).  2 -
      those that match against the ESX vmhosts that make up the cluster
      (esx_hostname, vmhost_rack, etc.).  3 - those that match against
      the virtual machines running on the cluster (virtual_machine,
      guest).
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --cluster_exact_location and --vmhost_exact_location options can be used
      to override this behavior.
      <optgroup name="search_cluster_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="metacluster" type="string">metacluster name</option>
         <option name="esx_hostname" type="string">fully qualified domain name of a vmhost</option>
         <option name="virtual_machine" type="string">virtual machine label (evm1)</option>
         <option name="guest" type="string">fully qualified host name of a virtual machine</option>
         <option name="archetype" type="string">archetype (vmhost)</option>
         <option name="personality" type="string">personality</option>
         <option name="service" type="string">client of service (single service only)</option>
         <option name="instance" type="string">client of service instance (single instance only)</option>
         <option name="share" type="string">nas_disk_share in use by an virtual machine on the cluster</option>
         <option name="capacity_override" type="flag">Select clusters with capacity overrides</option>
         <option name="switch" type="string">Select clusters bound to the given switch</option>
         <option name="buildstatus" type="string">status</option>
         <optgroup name="search_cluster_branch" fields="any">
            <option name="domain" type="string" conflicts="sandbox branch">template domain</option>
            <option name="sandbox" type="string" conflicts="domain branch">Name of the sandbox (given as 'author/branch')</option>
            <option name="branch" type="string" conflicts="domain sandbox">template branch (either a domain or a sandbox)</option>
         </optgroup>
         <optgroup name="search_cluster_location_opts" fields="any">
	    <option name="cluster_organization" type="string">Cluster Organization</option>
	    <option name="cluster_hub" type="string">Cluster Hub</option>
	    <option name="cluster_continent" type="string">Cluster Continent</option>
	    <option name="cluster_country" type="string">Cluster Country</option>
	    <option name="cluster_campus" type="string">Cluster Campus</option>
	    <option name="cluster_city" type="string">Cluster City</option>
	    <option name="cluster_building" type="string">Cluster Building</option>
	    <option name="cluster_room" type="string">Cluster Room</option>
	    <option name="cluster_rack" type="string">Cluster Rack</option>
	    <option name="cluster_desk" type="string">Cluster Desk</option>
         </optgroup>
         <option name="cluster_exact_location" type="flag">match the cluster location exactly</option>
         <optgroup name="search_vmhost_location_opts" fields="any">
	    <option name="vmhost_organization" type="string">vmhost Organization</option>
	    <option name="vmhost_hub" type="string">vmhost Hub</option>
	    <option name="vmhost_continent" type="string">vmhost Continent</option>
	    <option name="vmhost_country" type="string">vmhost Country</option>
	    <option name="vmhost_campus" type="string">vmhost Campus</option>
	    <option name="vmhost_city" type="string">vmhost City</option>
	    <option name="vmhost_building" type="string">vmhost Building</option>
	    <option name="vmhost_room" type="string">vmhost Room</option>
	    <option name="vmhost_rack" type="string">vmhost Rack</option>
	    <option name="vmhost_desk" type="string">vmhost Desk</option>
         </optgroup>
         <option name="vmhost_exact_location" type="flag">match the vmhost location exactly</option>
         <option name="all" type="flag">list all ESX clusters</option>
      </optgroup>
      <optgroup name="search_cluster_prefs" mandatory="False">
         <option name="fullinfo" type="flag">show full information for the matching clusters</option>
      </optgroup>
      <transport method="get" path="find/cluster/esx" />
   </command>

   <command name="search_observed_mac">
      Search poll_switch results.

      Supported options for --format: csv.

      The 'csv' format contains the following fields, in this order:
      Switch FQDN, port, MAC address, Last Observation Date
      <optgroup name="search_observed_mac_opts" mandatory="True" fields="any">
         <option name="tor_switch" type="string" conflicts="switch">(Deprecated.) FQDN of the switch</option>
         <option name="switch" type="string" conflicts="tor_switch">FQDN of the switch</option>
         <option name="port_number" type="int">Port number on the switch</option>
         <option name="mac" type="mac">MAC address to search for</option>
      </optgroup>
      <transport method="get" path="find/observed_mac" />
   </command>

   <command name="search_next">
      Search for the next available number in a series.  If entries are
      found in the database of the prefix followed by a number, the
      numbers are sorted and the highest number plus one is returned.
      If no entries are found, the command returns 1.  If the --pack
      option is given the first free value is returned instead of choosing
      one past the highest.  This will fill in any "holes" in the sequence.
      <p/>
      Use the --number flag to return just that number, otherwise
      return the full name.
      <p/>
      Use the --start option to count from a number other than 1.
      <p/>
      Examples:
      <p/>
      aq search_next --machine evm
      <p/>
      aq search_next --short igrid --dns_domain devin1.ms.com --number
      <p/>
      aq search_next --cluster ddecl
      <p/>
      aq search_next --metacluster namc
      <optgroup name="search_next_type" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="short cluster metacluster">Machine prefix to check</option>
         <optgroup name="search_next_fqdn" fields="all">
            <option name="short" type="string" conflicts="machine cluster metacluster">FQDN prefix to check</option>
            <option name="dns_domain" type="string">DNS domain for FQDN</option>
         </optgroup>
         <option name="cluster" type="string" conflicts="machine short metacluster">Cluster prefix to check</option>
         <option name="metacluster" type="string" conflicts="machine short cluster">Metacluster prefix to check</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="number" type="flag">show only the next number</option>
         <option name="pack" type="flag">Return first free value</option>
         <option name="start" type="string">Start counting at a different number than one</option>
      </optgroup>
      <transport method="get" trigger="short" path="find/next/system" />
      <transport method="get" trigger="machine" path="find/next/machine" />
      <transport method="get" trigger="cluster" path="find/next/cluster" />
      <transport method="get" trigger="metacluster" path="find/next/metacluster" />
   </command>

   <command name="compile">
      Compile anything that is out-of-date within a specified domain,
      sandbox, or only for the specified host.  Only out of date profiles
      will be compiled.
      <optgroup name="compile_input" mandatory="True" fields="any">
         <option name="domain" type="string" conflicts="sandbox hostname cluster">Domain name</option>
         <option name="sandbox" type="string" conflicts="domain hostname cluster">Name of the sandbox (given as 'author/branch')</option>
         <option name="hostname" type="string" conflicts="domain sandbox cluster">FQDN</option>
         <option name="cluster" type="string" conflicts="domain sandbox hostname">Name of cluster</option>
      </optgroup>
      <optgroup name="compile_optional" mandatory="False" fields="any">
         <option name="pancinclude" type="string" conflicts="pancdebug">Regex for templates to include in debug output (None included by default)</option>
         <option name="pancexclude" type="string" conflicts="pancdebug">Regex for templates to exclude in debug output (only useful if pancinclude has been given)</option>
         <option name="pancdebug" type="boolean" conflicts="pancinclude pancexclude">Alias for pancinclude=.* and pancexclude=components/spma/functions</option>
         <option name="cleandeps" type="boolean">Remove pan dependecy files before compiling (should only be required if switching panc versions)</option>
      </optgroup>
      <transport method="post" path="compile"/>
      <transport trigger="hostname" method="post" path="host/%(hostname)s/command/compile" />
      <transport trigger="cluster" method="post" path="cluster/%(cluster)s/command/compile" />
   </command>

   <command name="show_domain">
      Shows the configuration for a given domain. With the '--all' option,
      every domain will be listed with its configuration.
      <optgroup name="show_domain_Input" mandatory="True" fields="any">
         <option name="domain" type="string" conflicts="all">Domain name</option>
         <option name="all" type="flag" conflicts="hostname">Select all domains</option>
      </optgroup>
      <transport trigger="all" method="get" path="domain" />
      <transport trigger="domain" method="get" path="domain/%(domain)s" />
   </command>

   <command name="search_domain">
      Search domains.
      <optgroup name="search_domain_input" mandatory="True" fields="any">
         <option name="track" type="string" conflicts="start">Name of tracked branch</option>
         <option name="change_manager" type="boolean">Change manager required</option>
         <option name="owner" type="string">Show only domains of a given user</option>
         <option name="compiler_version" type="string">Version of panc to use</option>
         <option name="autosync" type="boolean">Filter by the autosync flag</option>
         <option name="validated" type="boolean">Filter by the validated flag</option>
      </optgroup>
      <optgroup name="search_sandbox_options" mandatory="False">
         <option name="fullinfo" type="flag">Show full information for the matching domains</option>
      </optgroup>
      <transport method="get" path="find/domain" />
   </command>

   <command name="show_sandbox">
      Shows the configuration for a given sandbox.  With the '--all' option,
      every sandbox will be listed with its configuration.
      <optgroup name="show_sandbox_Input" mandatory="True" fields="any">
         <option name="sandbox" type="string" conflicts="all">Sandbox name</option>
         <option name="all" type="flag" conflicts="hostname">Select all sandboxes</option>
      </optgroup>
      <optgroup name="show_sandbox_options" mandatory="False">
         <option name="pathonly" type="flag" conflicts="all">Show only the sandbox path</option>
      </optgroup>
      <transport trigger="all" method="get" path="sandbox/command/show_all" />
      <transport trigger="sandbox" method="get" path="sandbox/command/show" />
   </command>

   <command name="search_sandbox">
      <optgroup name="search_sandbox_input" mandatory="True" fields="any">
         <option name="owner" type="string">Show only sandboxes of a given user</option>
         <option name="compiler_version" type="string">Version of panc to use</option>
         <option name="autosync" type="boolean">Filter by the autosync flag</option>
         <option name="validated" type="boolean">Filter by the validated flag</option>
      </optgroup>
      <optgroup name="search_sandbox_options" mandatory="False">
         <option name="fullinfo" type="flag">Show full information for the matching sandboxes</option>
      </optgroup>
      <transport method="get" path="find/sandbox" />
   </command>

   <command name="show_network">
      Shows the configuration for a network, or for networks selected by location.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      The 'csv' format contains the following fields, in this order:
      Network name, IP, Netmask, Sysloc, Country code, Side, Type, Comments.
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --exact_location option can be used to override this behavior.
      <optgroup name="show_network_Input" mandatory="True" fields="any">
         <option name="network" type="string" conflicts="">Network name</option>
         <option name="ip" type="ipv4" conflicts="">IP address</option>
         <option name="all" type="flag" conflicts="">All</option>
         <optgroup name="show_network_options" fields="any">
            <option name="type" type="string">Network type</option>
            <option name="hosts" type="flag">Hosts</option>
         </optgroup>
         <optgroup name="show_network_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="exact_location" type="flag">match the location exactly</option>
      </optgroup>
      <optgroup name="show_network_prefs" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="get" path="network" />
   </command>

   <command name="search_network">
      Search for a network based on various criteria.
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --exact_location option can be used to override this behavior.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      The 'csv' format contains the following fields, in this order:
      Network name, IP, Netmask, Sysloc, Country code, Side, Type, Comments.
      <optgroup name="search_network_Input" mandatory="True" fields="any">
         <option name="network" type="string">Network name</option>
         <option name="ip" type="ipv4">IP address of the network or contained in the network</option>
         <option name="type" type="string">Network type</option>
         <option name="machine" type="string">Networks the machine is attached to</option>
         <option name="fqdn" type="string">Network that contains the IP address for this fully qualified domain name</option>
         <option name="cluster" type="string">Networks in use by the cluster switch</option>
         <option name="pg" type="string">Networks assigned to the given portgroup</option>
         <option name="has_dynamic_ranges" type="flag">Matches networks containing dynamic DHCP ranges</option>
         <option name="exact_location" type="flag">match the location exactly</option>
         <option name="all" type="flag">All</option>
         <optgroup name="search_network_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <optgroup name="search_network_prefs" mandatory="False">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
         <option name="fullinfo" type="flag">show full information for the matching networks</option>
      </optgroup>
      <transport method="get" path="find/network" />
   </command>

   <command name="refresh_network">
      Refresh aqdb network information from dsdb.
      <p/>
      Generally this command is called with the --all option but can be
      restricted to a single building for speed.  A dryrun option is
      provided to see what would change.
      <p/>
      Using the incremental option will cause every change to be committed
      to the database individually.  This is recommended for automated
      usage but is off by default for interactive use as it is slower.
      <optgroup name="refresh_network_mandatory" mandatory="True" fields="any">
         <option name="building" type="string" conflicts="all">Building name</option>
         <option name="all" type="flag" conflicts="building">All locations</option>
      </optgroup>
      <optgroup name="refresh_network_optional" mandatory="False">
         <option name="dryrun" type="boolean" conflicts="incremental">Report what will change</option>
         <option name="incremental" type="boolean" conflicts="dryrun">Commit every change as it is decided</option>
      </optgroup>
      <transport method="post" path="command/net_refresh" />
   </command>

   <command name="refresh_windows_hosts">
      Refresh Windows host entries based on information in the data warehouse.
      <p/>
      The data warehouse contains a merge of host/machine/interface data
      from both aqdb and Windows hosts using those interfaces.  This syncs
      up any non-conflicting data.
      <p/>
      The add_windows_host and del_windows_host commands can be used to
      create entries manually.
      <optgroup name="refresh_windows_hosts_optional" mandatory="False">
         <option name="dryrun" type="boolean" conflicts="">Report what will change</option>
      </optgroup>
      <transport method="post" path="command/refresh_windows_hosts" />
   </command>

   <command name="show_hostiplist">
      Shows a list of all hosts.  Can be narrowed by archetype.
      <optgroup name="show_hostiplist_options">
         <option name="archetype" type="string">Archetype name</option>
      </optgroup>
      <transport trigger="archetype" method="get" path="search/hostiplist/archetype/%(archetype)s" />
      <transport method="get" path="search/hostiplist" />
   </command>

   <command name="show_machinemaclist">
      Shows a list of all MAC addresses.
      <transport method="get" path="search/machinemaclist" />
   </command>

   <command name="show_hostmachinelist">
      %prog show hostmachinelist
      Shows a list of all hosts and the machine (aka node) they're associated with.
      <optgroup name="show_hostmachinelist_options">
         <option name="archetype" type="string">Archetype name</option>
      </optgroup>
      <transport trigger="archetype" method="get" path="archetype/%(archetype)s/hostmachinelist" />
      <transport method="get" path="search/hostmachinelist" />
   </command>

   <command name="add_cpu">
      Add a new CPU type to the database.
      <optgroup name="add_cpu_opts" mandatory="True" fields="all">
         <option name="cpu" type="string">CPU type name</option>
         <option name="vendor" type="string">name of the vendor</option>
         <option name="speed" type="int">CPU speed</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="hardware/cpu/%(vendor)s/%(cpu)s/%(speed)s" />
   </command>

   <command name="show_cpu">
      Show the CPU types in the database
      <optgroup name="show_cpu_opts" mandatory="True" fields="any">
         <option name="all" type="flag">Show all cpu types</option>
         <option name="cpu" type="string">CPU type name</option>
         <option name="vendor" type="string">name of the vendor</option>
         <option name="speed" type="int">CPU speed</option>
      </optgroup>
      <transport method="get" path="find/hardware/cpu" />
   </command>

   <command name="del_cpu">
      Delete a CPU type from the database
      <optgroup name="del_cpu_opts" mandatory="True" fields="all">
         <option name="cpu" type="string">CPU type name</option>
         <option name="vendor" type="string">name of the vendor</option>
         <option name="speed" type="int">CPU speed</option>
      </optgroup>
      <transport method="delete" path="hardware/cpu/%(vendor)s/%(cpu)s/%(speed)s" />
   </command>

   <command name="add_disk">
      Add a new disk to a machine.
      <p/>
      The controller type must be one of: ide, scsi, sata, sas, cciss.
      <p/>
      Examples of valid disk names: hda, hdb (IDE); sda, sdb (SCSI, SATA), c0d0 (CCISS).
      <optgroup name="add_disk_opts" mandatory="True" fields="all">
         <option name="machine" type="string">Machine name</option>
	 <option name="disk" type="string">Disk/device name</option>
         <optgroup name="controller_opts" fields="any">
            <option name="controller" type="string" conflicts="type">Type of the controller/interface</option>
	    <option name="type" type="string" conflicts="controller">[Deprecated] Type of the controller/interface</option>
         </optgroup>
         <optgroup name="size_opts" fields="any">
            <option name="size" type="int" conflicts="capacity">Capacity of the disk (GB)</option>
            <option name="capacity" type="int" conflicts="size">[Deprecated] Capacity of the disk (GB)</option>
         </optgroup>
      </optgroup>
      <optgroup name="nas_opts" fields="all">
         <optgroup name="share_opts" fields="any">
            <option name="share" type="string" conflicts="autoshare">Share name (an instance of nas_disk_share service)</option>
            <option name="autoshare" type="flag" conflicts="share">Resource pool will pick an appropriate share</option>
         </optgroup>
         <option name="address" type="string">Bus address (e.g. 0:0)</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
         <option name="boot" type="boolean">Mark the disk as bootable</option>
      </optgroup>
      <transport method="put" path="machine/%(machine)s/disk/%(disk)s" />
   </command>

   <command name="del_disk">
      Delete a disk from a machine.
      <p/>
      If more than one disk matches, they will not be deleted.  Use the
      --all flag to override this and delete all matching disks.
      <optgroup name="del_disk_opts" mandatory="True" fields="all">
         <option name="machine" type="string">machine ID</option>
      </optgroup>
      <optgroup name="del_disk_optional_opts" mandatory="False">
         <option name="disk" type="string">device name of the disk (like sda)</option>
         <optgroup name="controller_opts" fields="any">
            <option name="controller" type="string" conflicts="type">type of the disk</option>
            <option name="type" type="string" conflicts="controller">[Deprecated] type of the disk</option>
         </optgroup>
         <optgroup name="size_opts" fields="any">
            <option name="size" type="int" conflicts="capacity">capacity of the disk (GB)</option>
            <option name="capacity" type="int" conflicts="size">[Deprecated] capacity of the disk (GB)</option>
         </optgroup>
         <option name="all" type="flag">remove any matching disks</option>
      </optgroup>
      <transport trigger="disk" method="delete" path="machine/%(machine)s/disk/%(disk)s" />
      <transport method="post" path="hardware/disk/%(machine)s/command/del" />
   </command>

   <command name="add_host">
      Add a new host to the database.  Requires a machine with a bootable
      interface and a valid IP address.
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <p/>
      Specifying the --zebra_interfaces option will make the primary IP address of the host managed
      by Zebra. The argument of the option is a comma-separated list of interface names, where
      Zebra should be configured.
      <optgroup name="add_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
         <option name="machine" type="string">Machine (Node) name</option>
         <option name="archetype" type="string">Archetype name</option>
         <optgroup name="add_host_branch" mandatory="True" fields="any">
            <option name="domain" type="string" conflicts="sandbox">Template (not DNS) domain</option>
            <option name="sandbox" type="string" conflicts="domain">Name of the sandbox (given as 'author/branch')</option>
         </optgroup>
         <optgroup name="add_host_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
            <option name="autoip" type="flag" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">Operating system (e.g. linux)</option>
         <option name="osversion" type="string">Operating system version (e.g. 5.0-x86_64)</option>
         <option name="buildstatus" type="string">Build Status: defaults to build.  'blind' and 'ready' also valid.</option>
         <option name="personality" type="string">Personality name: defaults to 'inventory' for aquilon and 'generic' otherwise.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
         <option name="zebra_interfaces" type="string">Interfaces to configure Zebra on</option>
         <option name="comments" type="string">Comments</option>
         <option name="grn" type="string" conflicts="eon_id">GRN as string</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID</option>
      </optgroup>
      <transport method="put" path="host/%(hostname)s" />
   </command>

   <command name="add_aquilon_host">
      Add a new host to the database with archetype aquilon.  Requires a
      machine with a bootable interface and a valid IP address.
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_aquilon_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
         <option name="machine" type="string">Machine (Node) name</option>
         <optgroup name="add_host_branch" mandatory="True" fields="any">
            <option name="domain" type="string" conflicts="sandbox">Template (not DNS) domain</option>
            <option name="sandbox" type="string" conflicts="domain">Name of the sandbox (given as 'author/branch')</option>
         </optgroup>
         <optgroup name="add_host_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
            <option name="autoip" type="flag" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">Operating system (e.g. linux)</option>
         <option name="osversion" type="string">Operating system version (e.g. 5.0-x86_64)</option>
         <option name="buildstatus" type="string">Build Status: defaults to build.  'blind' and 'ready' also valid.</option>
         <option name="comments" type="string">Comments</option>
         <option name="personality" type="string">Personality name.  Defaults to 'inventory'.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
         <option name="zebra_interfaces" type="string">Interfaces to configure Zebra on</option>
         <option name="grn" type="string" conflicts="eon_id">GRN as string</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID</option>
      </optgroup>
      <transport method="put" path="aquilon_host/%(hostname)s" />
   </command>

   <command name="add_windows_host">
      Add a new host to the database with archetype windows.  Requires a
      machine with a bootable interface and a valid IP address.
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <p/>
      Currently operating system name/version is windows/generic for all windows
      machines since they are the only versions in the database.
      <optgroup name="add_windows_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
         <option name="machine" type="string">Machine (Node) name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="buildstatus" type="string">Build Status: defaults to build.  'blind' and 'ready' also valid.</option>
         <option name="personality" type="string">Personality name.  See `aq show personality --archetype windows`.  Currently defaults to 'generic'.</option>
         <option name="osversion" type="string">Operating system version.  Default 'generic'.</option>
         <option name="comments" type="string">Comments</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
         <optgroup name="add_host_ip_opts" mandatory="False" fields="any">
            <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
            <option name="autoip" type="flag" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         </optgroup>
         <option name="grn" type="string" conflicts="eon_id">GRN as string</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID</option>
      </optgroup>
      <transport method="put" path="windows_host/%(hostname)s" />
   </command>

   <command name="add_aurora_host">
      Add a placeholder host to the database to represent an aurora host.
      <optgroup name="add_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">Operating system: defaults to linux, no solaris (yet)</option>
         <option name="osversion" type="string">Operating system version (e.g. 5.0-x86_64. Defaults to 'generic')</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="aurora_host/%(hostname)s" />
   </command>

   <command name="add_auxiliary">
      Add an auxiliary entry for a host to the database.  Requires a
      machine with a non-bootable public interface (generally eth1) and a
      valid IP address.
      <p/>
      The host can be identified by either --machine or --hostname.  The
      new/auxiliary name must be given with --auxiliary.
      <p/>
      If both --interface and --mac are given and there is no such
      interface, it will be created.
      <p/>
      For a host like igrid123.subdomain.ms.com, an example auxiliary name
      for the eth1 interface is igrid123-e1.subdomain.ms.com.
      <p/>
      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_aux_opts" mandatory="True" fields="all">
         <optgroup name="add_aux_identifier" mandatory="True" fields="any">
            <option name="hostname" type="string" conflicts="machine">Fully qualified Host name</option>
            <option name="machine" type="string" conflicts="hostname">Machine (Node) name</option>
	 </optgroup>
         <option name="auxiliary" type="string">Fully qualified name for the auxiliary interface</option>
	 <optgroup name="add_aux_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
	    <option name="autoip" type="flag" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
	 </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="interface" type="string">Specify the non-bootable public interface to use, if there is more than one.</option>
         <option name="mac" type="mac">Specify the non-bootable public interface to use, if there is more than one.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="auxiliary/%(auxiliary)s" />
   </command>

   <command name="show_auxiliary">
      Shows the information for auxiliary systems (like
      igrid123-e1.subdomain.ms.com)
      <optgroup name="show_auxiliary_opts" mandatory="True" fields="any">
         <option name="auxiliary" type="string" conflicts="all">Auxiliary name</option>
         <option name="all" type="flag" conflicts="auxiliary">Select all auxiliaries</option>
      </optgroup>
      <transport trigger="all" method="get" path="auxiliary" />
      <transport trigger="auxiliary" method="get" path="auxiliary/%(auxiliary)s" />
   </command>

   <command name="del_auxiliary">
      Delete an auxiliary entry for a host from the database.
      <p/>
      For a host like igrid123.subdomain.ms.com, an example auxiliary name
      for the eth1 interface is igrid123-e1.subdomain.ms.com.
      <p/>
      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).
      <optgroup name="add_aux_opts" mandatory="True" fields="all">
         <option name="auxiliary" type="string">Fully qualified name for the auxiliary interface</option>
      </optgroup>
      <transport method="delete" path="auxiliary/%(auxiliary)s" />
   </command>

   <command name="add_manager">
      Add a manager entry for a host to the database.  Requires a
      host with a management interface and a valid IP address.
      <p/>
      The manager name can be overridden with --manager.  The default
      is to add an 'r' to the first component of the hostname.  For a
      host like igrid123.subdomain.ms.com, the default manager name
      is igrid123r.subdomain.ms.com.
      <p/>
      If both --interface and --mac are given and there is no such
      interface, it will be created.
      <p/>
      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_manager_opts" mandatory="True" fields="all">
         <option name="hostname" type="string" conflicts="machine">Fully qualified Host name</option>
	 <optgroup name="add_manager_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
	    <option name="autoip" type="flag" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
	 </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="manager" type="string">Fully qualified name for the manager interface</option>
         <option name="interface" type="string">Specify the management interface to use, if there is more than one.</option>
         <option name="mac" type="mac">Specify the management interface to use, if there is more than one.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport trigger="manager" method="put" path="manager/%(manager)s" />
      <transport method="post" path="host/%(hostname)s/command/add_manager" />
   </command>

   <command name="show_manager">
      Shows the information for manager systems (like
      igrid123r.subdomain.ms.com)
      <p/>
      The --missing option will list aq commands to create entries for
      any hosts that have management interfaces but do not have managers.
      <p/>
      These commands need to be run separately in order to create the
      necessary entries.
      <optgroup name="show_manager_opts" mandatory="True" fields="any">
         <option name="manager" type="string" conflicts="all missing">Manger name</option>
         <option name="all" type="flag" conflicts="manager missing">Select all managers</option>
         <option name="missing" type="boolean" conflicts="manager all">Generate commands to create missing managers</option>
      </optgroup>
      <transport trigger="all" method="get" path="manager" />
      <transport trigger="manager" method="get" path="manager/%(manager)s" />
      <transport trigger="missing" method="get" path="find/missing_managers" />
   </command>

   <command name="del_manager">
      Delete a manager entry for a host from the database.
      <p/>
      For a host like igrid123.subdomain.ms.com, the manager name
      is igrid123r.subdomain.ms.com.
      <p/>
      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).
      <optgroup name="del_manager_opts" mandatory="True" fields="all">
         <option name="manager" type="string">Fully qualified name for the manager interface</option>
      </optgroup>
      <transport method="delete" path="manager/%(manager)s" />
   </command>

   <command name="add_model">
      Add a new model
      <optgroup name="add_model_opts" mandatory="True" fields="all">
         <option name="model" type="string">Name of the new model</option>
         <option name="vendor" type="string">Vendor name</option>
         <option name="type" type="string">Machine type name</option>
      </optgroup>
      <optgroup name="default_config_opts" mandatory="False" fields="all">
         <optgroup name="cpu_spec" mandatory="False" fields="any">
            <option name="cputype" type="string" conflicts="cpuname">[Deprecated] CPU type</option>
            <option name="cpuname" type="string" conflicts="cputype">CPU type</option>
         </optgroup>
         <option name="cpunum" type="int">CPU count</option>
         <option name="memory" type="int">amount of installed memory (MB)</option>
         <option name="disktype" type="string">installed disk type (generally 'local', use 'nas' for virtual disks on NAS)</option>
         <option name="diskcontroller" type="string">controller type (sata, scsi, etc.)</option>
         <option name="disksize" type="int">installed disk capacity (GB)</option>
         <option name="nics" type="int">number of NIC interfaces</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="cpuvendor" type="string">CPU vendor, if the name is not unique</option>
         <option name="cpuspeed" type="int">CPU speed, if the name is not unique</option>
         <option name="nicmodel" type="string">Default model of network interfaces</option>
         <option name="nicvendor" type="string">NIC vendor, if the model name is not unique</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="hardware/model/%(vendor)s/%(model)s" />
   </command>

   <command name="show_model">
      Show a model
      <optgroup name="show_model_opts" mandatory="True" fields="any">
         <option name="model" type="string">Name of the model</option>
         <option name="vendor" type="string">Vendor name</option>
         <option name="type" type="string">Machine type name</option>
         <option name="all" type="flag">Show all models</option>
      </optgroup>
      <transport method="get" path="find/hardware/model" />
   </command>

   <command name="update_model">
      Update a model, optionally updating all existing hardware of that model.
      The model must be specified by name and vendor.
      If updating the CPU, usually cpuname will be enough to specify a CPU
      uniquely but vendor and speed can be given as well if needed.
      <optgroup name="update_model_specifier" mandatory="True" fields="all">
         <option name="model" type="string">Name of the model to update</option>
         <option name="vendor" type="string">Vendor name</option>
      </optgroup>
      <optgroup name="update_model_values" mandatory="False">
         <option name="newmodel" type="string">Change model name</option>
         <option name="newvendor" type="string">Change model vendor</option>
         <option name="machine_type" type="string">Machine type name</option>
         <option name="cpuname" type="string">CPU name</option>
         <option name="cpuvendor" type="string">CPU vendor</option>
         <option name="cpuspeed" type="int">CPU speed</option>
         <option name="cpunum" type="int">CPU count</option>
         <option name="memory" type="int">amount of installed memory (MB)</option>
         <option name="disktype" type="string">installed disk type (generally 'local', use 'nas' for virtual disks on NAS)</option>
         <option name="diskcontroller" type="string">controller type (sata, scsi, etc.)</option>
         <option name="disksize" type="int">installed disk capacity (GB)</option>
         <option name="nics" type="int">number of NIC interfaces</option>
         <option name="nicmodel" type="string">NIC model name</option>
         <option name="nicvendor" type="string">NIC vendor</option>
         <option name="comments" type="string">Comments</option>
         <option name="leave_existing" type="boolean">Do not update machines using the old defaults to the new values</option>
      </optgroup>
      <transport method="post" path="hardware/model/%(vendor)s/%(model)s" />
   </command>

   <command name="del_model">
      Decomission model
      <optgroup name="del_model_opts" mandatory="True" fields="all">
         <option name="model" type="string">Name of the model</option>
         <option name="vendor" type="string">Vendor name</option>
      </optgroup>
      <transport method="delete" path="hardware/model/%(vendor)s/%(model)s" />
   </command>

   <command name="add_interface">
      Add a new network interface to the database.
      <p/>
      If adding an interface to virtual hardware, the --automac option
      can be used to automatically generate a MAC address based on
      the cluster vendor.
      <p/>
      To give an IP address to a host, provide it when using add_host.
      <p/>
      For chassis the IP address is provided with this command.
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_interface_opts" mandatory="True" fields="all">
         <option name="interface" type="string">Interface name</option>
      </optgroup>
      <optgroup name="add_interface_mac" mandatory="False">
         <option name="mac" type="mac" conflicts="automac">MAC address</option>
         <option name="automac" type="flag" conflicts="mac">Automatically generate MAC for virtual hardware</option>
      </optgroup>
      <optgroup name="add_interface_hw" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname chassis switch">Machine (node) name</option>
         <option name="hostname" type="string" conflicts="machine chassis switch">Hostname</option>
         <option name="chassis" type="string" conflicts="machine hostname switch">Chassis name</option>
         <option name="switch" type="string" conflicts="machine hostname chassis">Switch name</option>
      </optgroup>
      <optgroup name="add_interface_optional" mandatory="False" fields="none">
         <option name="type" type="string">Interface type: public, management, oa, vlan</option>
         <option name="comments" type="string">Comments</option>
         <option name="pg" type="string" conflicts="autopg">portgroup</option>
         <option name="autopg" type="flag" conflicts="pg">choose portgroup based on switch</option>
         <option name="model" type="string">Interface model name. Default is 'generic_nic'.</option>
         <option name="vendor" type="string">Interface vendor name. Default is 'generic'.</option>
      </optgroup>
      <transport trigger="machine" method="put" path="machine/%(machine)s/interface/%(interface)s" />
      <transport trigger="hostname" method="put" path="host/%(hostname)s/interface/%(interface)s" />
      <transport trigger="chassis" method="put" path="chassis/%(chassis)s/interface/%(interface)s" />
      <transport trigger="switch" method="put" path="switch/%(switch)s/interface/%(interface)s" />
   </command>

   <command name="add_network_environment">
      Define a new network environment.
      <optgroup name="add_netenv_mandatory" mandatory="True" fields="all">
	 <option name="network_environment" type="string">Name of the environment</option>
	 <option name="dns_environment" type="string">DNS environment to use for looking up addresses in this network environment</option>
      </optgroup>
      <optgroup name="add_netenv_optional" mandatory="False" fields="any">
	 <!-- TODO: Do we need any other kind of location? -->
	 <option name="building" type="string">Building</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="network_environment/%(network_environment)s"/>
   </command>

   <command name="del_network_environment">
      Delete a new network environment.
      <optgroup name="del_netenv_mandatory" mandatory="True" fields="all">
	 <option name="network_environment" type="string">Name of the environment</option>
      </optgroup>
      <transport method="delete" path="network_environment/%(network_environment)s"/>
   </command>

   <command name="update_network_environment">
      Update a new network environment.
      <optgroup name="add_netenv_mandatory" mandatory="True" fields="all">
	 <option name="network_environment" type="string">Name of the environment</option>
      </optgroup>
      <optgroup name="add_netenv_optional" mandatory="False" fields="any">
	 <!-- TODO: Do we need any other kind of location? -->
	 <option name="building" type="string">Building</option>
	 <option name="clear_location" type="flag" conflicts="building">Clear the location mapping</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="network_environment/%(network_environment)s"/>
   </command>

   <command name="show_network_environment">
      Display a new network environment.
      <optgroup name="show_netenv_options" mandatory="True" fields="any">
	 <option name="network_environment" type="string">Name of the environment</option>
	 <option name="all" type="flag">Show all environments</option>
      </optgroup>
      <transport trigger="network_environment" method="get" path="network_environment/%(network_environment)s"/>
      <transport trigger="all" method="get" path="network_environment"/>
   </command>

   <command name="search_network_environment">
      Display a new network environment.
      <optgroup name="search_netenv_options" mandatory="True" fields="any">
	 <option name="network_environment" type="string">Name of the environment</option>
	 <!-- TODO: Do we need any other kind of location? -->
	 <option name="building" type="string">Building</option>
      </optgroup>
      <transport method="get" path="find/network_environment"/>
   </command>

   <command name="add_network">
      Define a new network.
      <p/>
      Specify both a name for the network and its address as an IP
      address/netmask pair.  The netmask can be specified either as dotted quad
      (like "--netmask 255.255.255.0"), as prefix length (like "--prefixlen 24"),
      or as the number of hosts in the network (like "--mask 256").
      <optgroup name="add_network_mandatory" mandatory="True" fields="all">
         <option name="network" type="string">Network name</option>
         <option name="ip" type="ipv4">Network IP address</option>
         <optgroup name="add_network_netmask" mandatory="True" fields="any">
            <option name="netmask" type="string" conflicts="prefixlen mask">Netmask as dotted quad</option>
            <option name="prefixlen" type="int" conflicts="netmask mask">Network prefix length</option>
            <option name="mask" type="int" conflicts="netmask prefixlen">Number of hosts</option>
         </optgroup>
         <optgroup name="add_network_location_opts" mandatory="True" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>

      <optgroup name="add_network_modifiers" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
         <option name="type" type="string">Network type, defaults to 'unknown'</option>
         <option name="side" type="string">Network side, defaults to 'a'</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="network/%(ip)s" />
   </command>

   <command name="del_network">
      Remove a network definition.
      <p/>
      Specify the network by its IP.
      <optgroup name="del_network_mandatory" mandatory="True" fields="all">
         <option name="ip" type="ipv4">Network IP address</option>
      </optgroup>
      <optgroup name="del_network_modifiers" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="delete" path="network/%(ip)s" />
   </command>

   <command name="update_network">
     Update information about the specified network or networks.
     <p/>
     Update the network either by name or ip of the network.
     <optgroup name="update_network_opts" mandatory="True" fields="any">
	<option name="network" type="string">Network name</option>
	<option name="ip" type="ipv4">Network address</option>
     </optgroup>
     <optgroup name="update_network_modifiers" mandatory="True" fields="any">
	<option name="type" type="string">Network type</option>
	<option name="side" type="string">Network side</option>
	<option name="comments" type="string">Comments</option>
	<optgroup name="update_network_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
	</optgroup>
     </optgroup>
     <optgroup name="update_network_optional" mandatory="False" fields="any">
	<option name="network_environment" type="string">Network environment (default: internal)</option>
     </optgroup>
     <transport method="post" path="network" />
   </command>

   <command name="split_network">
      Split a network to smaller subnets.  Any devices on the old network will
      be reassigned to the new subnets.
      <optgroup name="split_network_mandatory" mandatory="True" fields="all">
         <option name="ip" type="ipv4">Network address</option>
	 <optgroup name="merge_network_netmask" mandatory="True" fields="any">
            <option name="netmask" type="ipv4" conflicts="prefixlen">New netmask</option>
            <option name="prefixlen" type="int" conflicts="netmask">New network prefix length</option>
	 </optgroup>
      </optgroup>
      <optgroup name="split_network_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="post" path="network/split" />
   </command>

   <command name="merge_network">
      Merge multiple networks.  The merged network will inherit its parameters (like location)
      from the network specifyed by --ip.  Note that --ip does not need to specify the
      first network to be merged: e.g. if you want to merge 4 existing networks, then --ip may
      point to the 2nd one; the IP address of the merged network will be calculated using 
      --prefixlen.
      <optgroup name="merge_network_mandatory" mandatory="True" fields="all">
         <option name="ip" type="ipv4">Network address</option>
	 <optgroup name="merge_network_netmask" mandatory="True" fields="any">
            <option name="netmask" type="ipv4" conflicts="prefixlen">New netmask</option>
            <option name="prefixlen" type="int" conflicts="netmask">New network prefix length</option>
	 </optgroup>
      </optgroup>
      <optgroup name="merge_network_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="post" path="network/merge" />
   </command>

   <command name="add_router">
      Add a router address.
      <optgroup name="add_router_mandatory" mandatory="True" fields="all">
         <option name="fqdn" type="string">Name of the router</option>
      </optgroup>
      <optgroup name="add_router_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
         <option name="building" type="string">Building where the router is located</option>
         <option name="ip" type="ipv4">IP address of the router</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="router" />
   </command>

   <command name="del_router">
      Delete a router address.
      <optgroup name="del_router_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string" conflicts="ip">Name of the router</option>
         <option name="ip" type="ipv4" conflicts="fqdn">IP address of the router</option>
      </optgroup>
      <optgroup name="del_router_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="delete" path="router" />
   </command>

   <command name="show_router">
      Display a router address.
      <optgroup name="show_router_opts" mandatory="False" fields="any">
         <option name="fqdn" type="string" conflicts="ip all">Name of the router</option>
         <option name="ip" type="ipv4" conflicts="fqdn all">IP address of the router</option>
         <option name="all" type="flag" conflicts="ip fqdn">Show all routers</option>
      </optgroup>
      <optgroup name="del_router_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="get" path="router" />
   </command>

   <command name="update_router">
      Update router information.
      <optgroup name="update_router_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string" conflicts="ip all">Name of the router</option>
         <option name="ip" type="ipv4" conflicts="fqdn all">IP address of the router</option>
      </optgroup>
      <optgroup name="update_router_settings" mandatory="False" fields="any">
         <option name="building" type="string">Building where the router is located</option>
         <option name="comments" type="string">Router comments</option>
      </optgroup>
      <transport method="post" path="router" />
   </command>

   <command name="add_static_route">
      Add a static route.
      <optgroup name="add_static_route_mandatory" mandatory="True" fields="all">
         <option name="gateway" type="ipv4">Address of the gateway</option>
         <option name="ip" type="ipv4">Address of the destination network range</option>
         <optgroup name="add_static_route_netmask" mandatory="True" fields="any">
            <option name="netmask" type="string" conflicts="prefixlen">Netmask as dotted quad</option>
            <option name="prefixlen" type="int" conflicts="netmask">Network prefix length</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_static_route_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="static_route" />
   </command>

   <command name="del_static_route">
      Delete a static route.
      <optgroup name="del_static_route_opts" mandatory="True" fields="all">
         <option name="gateway" type="ipv4">Address of the gateway</option>
         <option name="ip" type="ipv4">Address of the destination network range</option>
         <optgroup name="add_static_route_netmask" mandatory="True" fields="any">
            <option name="netmask" type="string" conflicts="prefixlen">Netmask as dotted quad</option>
            <option name="prefixlen" type="int" conflicts="netmask">Network prefix length</option>
         </optgroup>
      </optgroup>
      <optgroup name="del_static_route_optional" mandatory="False" fields="any">
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <transport method="delete" path="static_route" />
   </command>

   <command name="update_interface">
      Update information about the named interface (IP, MAC, or comments).
      <p/>
      To rename the interface, add the new interface and delete the old.
      If the boot flag is given, the interface will be marked bootable,
      and any other interface attached to the machine will have the bootable
      flag set to false.
      <p/>
      The default_route flag may be set on multiple interfaces to indicate that they should be used
      with equal cost. Note that for compatibility reasons, setting the boot flag also sets the
      default_route flag, and removes it from any other interfaces.
      <p/>
      For this change to take affect at the host level, run aq reconfigure.
      <p/>
      Note that updating the IP address is no longer supported. Use the add_interface_address and
      del_interface_address commands to manage auxiliary IP address allocations. Use the
      update_switch, update_chassis and update_machine commands if you wish to change the primary IP address.
      <optgroup name="update_interface_opts" mandatory="True" fields="all">
         <option name="interface" type="string">Interface name</option>
      </optgroup>
      <optgroup name="update_interface_hw_opts" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname switch chassis">Machine name</option>
         <option name="hostname" type="string" conflicts="machine switch chassis">Host name</option>
         <option name="switch" type="string" conflicts="machine hostname chassis">Switch name</option>
         <option name="chassis" type="string" conflicts="machine hostname switch">Chassis name</option>
      </optgroup>
      <optgroup name="update_interface_optional" mandatory="False" fields="none">
         <option name="mac" type="mac">MAC address</option>
         <option name="ip" type="ipv4" conflicts="master">IP address</option>
         <option name="boot" type="flag">Mark the interface as bootable</option>
         <option name="default_route" type="boolean">Mark that the interface provides the default route</option>
         <option name="pg" type="string" conflicts="autopg">portgroup, or an empty string to clear</option>
         <option name="autopg" type="flag" conflicts="pg">choose portgroup based on switch</option>
         <option name="comments" type="string">Comments</option>
         <option name="master" type="string" conflicts="ip clear_master">Enslave interface to the given master</option>
         <option name="clear_master" type="flag" conflicts="master">Clear the bonding</option>
         <option name="model" type="string">Interface model name</option>
         <option name="vendor" type="string">Interface vendor name</option>
      </optgroup>
      <transport trigger="machine" method="post" path="machine/%(machine)s/interface/%(interface)s" />
      <transport trigger="hostname" method="post" path="host/%(hostname)s/interface/%(interface)s" />
      <transport trigger="switch" method="post" path="switch/%(switch)s/interface/%(interface)s" />
      <transport trigger="chassis" method="post" path="chassis/%(chassis)s/interface/%(interface)s" />
   </command>

   <command name="del_interface">
      Delete a network interface from the database.
      <p/>
      The interface can be specified either by its MAC address or as a
      machine/interface name pair. If a machine has just a single interface
      then just specifying the machine name is enough.
      <p/>
      Note that you can not select an interface by IP address since the object
      that owns the IP address would have to be deleted before deleting the
      interface anyway.
      <optgroup name="del_interface_opts" mandatory="True" fields="any">
         <option name="interface" type="string">Interface name</option>
         <option name="machine" type="string">Machine name</option>
         <option name="switch" type="string">Switch name</option>
         <option name="chassis" type="string">Chassis name</option>
         <option name="mac" type="mac">MAC address</option>
      </optgroup>
      <transport method="post" trigger="switch" path="switch/%(switch)s/interface/command/del" />
      <transport method="post" path="interface/command/del" />
   </command>

   <command name="add_interface_address">
      Assign a new IP address to an interface.
      <p/>
      If you specify only --fqdn, and none of the IP generation options, then
      the appropriate DNS record must already exist. If you specify both --fqdn
      and an IP generation option, then a new DNS record will be created.
      <p/>
      Valid values for the --usage option are: "system" and "zebra". To
      configure Zebra, the same IP address with the same label and with
      "--usage zebra" must be added to multiple physical interfaces.
      <optgroup name="add_interface_address_req" mandatory="True" fields="all">
         <optgroup name="add_interface_address_hw_opts" mandatory="True" fields="any">
            <option name="machine" type="string" conflicts="chassis switch">Machine name</option>
            <option name="chassis" type="string" conflicts="machine switch">Chassis name</option>
            <option name="switch" type="string" conflicts="machine chassis">Switch name</option>
         </optgroup>
         <option name="interface" type="string">Name of the interface.</option>
      </optgroup>
      <optgroup name="add_interface_address_opt" mandatory="False" fields="any">
	 <option name="fqdn" type="string">FQDN of the new address</option>
	 <option name="network_environment" type="string">Network environment (default: internal)</option>
	 <option name="label" type="string">Interface alias of the new address</option>
	 <option name="usage" type="string">Use of the new address (default: system)</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
      </optgroup>
      <optgroup name="add_interface_address_ip_opts" mandatory="False" fields="any">
         <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem autoip">IP address</option>
         <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
         <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
         <option name="autoip" type="flag" conflicts="ip ipfromip ipfromsystem">choose IP address based on MAC/switch</option>
      </optgroup>
      <transport method="put" trigger="switch" path="switch/%(switch)s/interface/%(interface)s/address"/>
      <transport method="put" path="interface_address"/>
   </command>

   <command name="del_interface_address">
      Delete an IP address from an interface.
      <optgroup name="del_interface_address_hw_opts" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="chassis switch">Machine name</option>
         <option name="chassis" type="string" conflicts="machine switch">Chassis name</option>
         <option name="switch" type="string" conflicts="machine chassis">Switch name</option>
      </optgroup>
      <optgroup name="del_interface_address_req" mandatory="True" fields="all">
         <option name="interface" type="string">Name of the interface</option>
      </optgroup>
      <optgroup name="del_interface_address_opt" mandatory="False" fields="any">
         <option name="keep_dns" type="flag">Keep the DNS record</option>
         <option name="network_environment" type="string">Network environment (default: internal)</option>
      </optgroup>
      <optgroup name="del_interface_address_ip_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string" conflicts="ip">FQDN of the address</option>
         <option name="ip" type="ipv4" conflicts="fqdn">IP address</option>
         <option name="label" type="string" conflicts="fqdn">Interface alias</option>
      </optgroup>
      <transport method="delete" trigger="switch" path="switch/%(switch)s/interface/%(interface)s/address"/>
      <transport method="delete" path="interface_address"/>
   </command>

   <command name="add_service">
      Add a new service. If --instance is also specified, then also
      create a named instance for this service at the same time. Default templates
      describing the service will be created so that any service instances can be
      immediately used (bound and configured) by clients.
      <optgroup name="add_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
         <option name="instance" type="string">Instance</option>
      </optgroup>
      <transport method="put" path="service/%(service)s" />
      <transport trigger="instance" method="put" path="service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="add_nas_disk_share">
     Add a new NAS share service instance. If the --manager property is set, membership and capacity
     management is deferred to an external manager such as  Resource Pool. Default templates
      describing the service will be created so that shares can be immediately used (bound and configured) by clients.
      <optgroup name="add_nas_disk_share_opts" mandatory="True" fields="all">
         <option name="share" type="string" mandatory="True">share name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
         <option name="manager" type="string">External Manager (resourcepool, ...)</option>
      </optgroup>
      <transport method="put" path="/nas_disk_share/instance/%(share)s" />
   </command>
   
   <command name="show_service">
      Show the configuration of a service. All instances of the service will
      be listed, the number of clients bound to that service and any service mappings.
      If --all is specified, then the configuration of all services will be shown.
      <optgroup name="show_service_opts" mandatory="True" fields="any">
         <option name="service" type="string">Service name</option>
         <option name="server" type="string" conflict="client">Server hostname</option>
	 <option name="client" type="string" conflicts="server">Client hostname</option>
	 <option name="all" type="flag" conflicts="service">Select all services</option>
      </optgroup>
      <optgroup name="show_service_optional_opts">
	 <option name="instance" type="string">Service Instance</option>
      </optgroup>
      <transport trigger="service" method="get" path="service/%(service)s"/>
      <transport method="get" path="service" />
   </command>

   <command name="show_nas_disk_share">
      Show information for instances of the nas_disk_share service.
      <optgroup name="show_share_opts" mandatory="True" fields="any">
         <option name="share" type="string" conflicts="all">Share name</option>
         <option name="all" type="flag" conflicts="share">Select all shares</option>
      </optgroup>
      <transport trigger="share" method="get" path="nas_disk_share/%(share)s"/>
      <transport trigger="all" method="get" path="nas_disk_share" />
   </command>

   <command name="update_service">
      Update the maximum client count for a service or service instance.
      <p/>
      The maximum client count for a service instance will default to
      the value set for the service.  The maximum client count for a
      service defaults to unlimited.
      <optgroup name="update_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <optgroup name="update_service_count" mandatory="True" fields="any">
            <option name="max_clients" type="int" conflicts="default">Maximum number of client bindings for an instance</option>
            <option name="default" type="flag" conflicts="max_clients">Restore default setting</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="service/%(service)s" />
      <transport trigger="instance" method="post" path="service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="del_service">
      Delete a service. The command will fail if any servers or clients are marked
      as being bound to any of the instances of the service.
      <optgroup name="del_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="instance" type="string">instance name</option>
      </optgroup>
      <transport method="delete" path="service/%(service)s" />
      <transport trigger="instance" method="delete" path="service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="bind_client">
      Bind a service to a client.  If no instance is given and a relevant
      service map has been defined, an instance will be picked automatically.
      If the client already has the service bound, this will fail: use rebind
      client instead.
      <optgroup name="bind_client_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <optgroup name="bind_client_optional_opts">
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/client_of_service/%(service)s/bind" />
   </command>

   <command name="rebind_client">
      Bind a service to a client.  If no instance is given and a relevant
      service map has been defined, an instance will be picked automatically.
      If the client already has the service bound, this will override the old value.
      <optgroup name="rebind_client_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <optgroup name="rebind_client_optional_opts">
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/client_of_service/%(service)s/rebind" />
   </command>

   <command name="unbind_client">
      Unbind a service from a client.
      <optgroup name="unbind_service_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <transport method="delete" path="host/%(hostname)s/client_of_service/%(service)s" />
   </command>

   <command name="bind_server">
      Bind a server as a provider of the service instance.
      If the server is already bound as a provider of the service for a
      different instance, this fails.
      <optgroup name="bind_client_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Server name</option>
         <option name="service" type="string">Service name</option>
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/server_of_service/%(service)s/bind" />
   </command>

   <command name="unbind_server">
      Unbind a server as a provider of the service (instance).
      <optgroup name="unbind_server_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <optgroup name="unbind_server_optional_opts" mandatory="True" fields="any">
         <option name="instance" type="string">Instance name</option>
         <option name="all" type="flag">Remove server from all instances of this service</option>
      </optgroup>
      <transport method="delete" path="host/%(hostname)s/server_of_service/%(service)s" />
      <transport trigger="instance" method="delete" path="host/%(hostname)s/server_of_service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="add_required_service">
      Add a required service for an archetype or for only a particular
      personality in the archetype.  Once a service is required, then
      any time a host of that archetype or personality is built, it
      will cause an implicit bind_server to occur for any unbound
      required services.  If an instance cannot be automatically bound,
      then hosts will fail to build, therefore you should ensure that
      any required services have appropriate service mappings to
      declare which instances to use by default.
      <optgroup name="add_required_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="archetype" type="string" mandatory="True">archetype name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="personality" type="string">personality name</option>
      </optgroup>
      <transport method="put" path="service/%(service)s/required_for/archetype/%(archetype)s" />
      <transport trigger="personality" method="put" path="service/%(service)s/required_for/personality/%(archetype)s/%(personality)s" />
   </command>

   <command name="show_archetype">
      Show information about an archetype, including required services.
      <optgroup name="show_archetype_opts" mandatory="True" fields="any">
         <option name="archetype" type="string">archetype name</option>
         <option name="all" type="flag" conflicts="archetype">Select all services</option>
      </optgroup>
      <transport trigger="archetype" method="get" path="archetype/%(archetype)s" />
      <transport trigger="all" method="get" path="archetype" />
   </command>

   <command name="del_required_service">
      Delete a service from the list of required services for an
      archetype or personality.  Hosts which are already bound to a
      service because it used to be required will be unmodified. If
      you wish to unbind those clients, you must do so manually.
      <optgroup name="del_required_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="archetype" type="string" mandatory="True">archetype name</option>
      </optgroup>
      <optgroup name="del_required_service_optional">
         <option name="personality" type="string" mandatory="True">personality name</option>
      </optgroup>
      <transport method="delete" path="service/%(service)s/required_for/archetype/%(archetype)s" />
      <transport trigger="personality" method="delete" path="service/%(service)s/required_for/personality/%(archetype)s/%(personality)s" />
   </command>

   <command name="map_service">
      Map a service instance to a location. This declares that the specified service
      instance is default within a specific location, and will be a candidate for
      automatic selection during any bind_server (or rebuilds that invoke bind_server)
      commands.
      <optgroup name="map_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="instance" type="string" mandatory="True">instance name</option>
      </optgroup>
      <optgroup name="map_service_personality_opts" fields="all">
         <option name="archetype" type="string">archetype name</option>
         <option name="personality" type="string">personality name</option>
      </optgroup>
      <optgroup name="map_service_location_opts" mandatory="True" fields="any">
        <option name="organization" type="string">Organization</option>
        <option name="hub" type="string">Hub</option>
        <option name="continent" type="string">Continent</option>
        <option name="country" type="string">Country</option>
        <option name="campus" type="string">Campus</option>
        <option name="city" type="string">City</option>
        <option name="building" type="string">Building</option>
        <option name="room" type="string">Room</option>
        <option name="rack" type="string">Rack</option>
        <option name="desk" type="string">Desk</option>
        <option name="networkip" type="ipv4" conflicts="organization hub continent country campus city building room rack desk">Network IP address</option>
      </optgroup>
      <transport method="post" path="service/%(service)s/instance/%(instance)s/command/map" />
   </command>

   <command name="show_map">
      Show any relevant mappings for the given service, instance, or location.
      <optgroup name="show_map_opts" mandatory="True" fields="any">
         <option name="service" type="string">service name</option>
         <option name="instance" type="string">instance name</option>
         <option name="archetype" type="string">archetype name</option>
         <option name="personality" type="string">personality name</option>
         <optgroup name="show_map_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="networkip" type="ipv4">Network IP address</option>
         <option name="all" type="flag">show all maps</option>
      </optgroup>
      <transport method="get" path="show/map" />
   </command>

   <command name="unmap_service">
      Remove the map from a service instance to a location. Existing bindings of
      clients will remain unmodified.
      <optgroup name="unmap_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="instance" type="string" mandatory="True">instance name</option>
      </optgroup>
      <optgroup name="unmap_service_personality_opts" mandatory="False" fields="all">
         <option name="archetype" type="string">archetype name</option>
         <option name="personality" type="string">personality name</option>
      </optgroup>
      <optgroup name="unmap_service_location_opts" mandatory="True" fields="any">
         <option name="organization" type="string">Organization</option>
         <option name="hub" type="string">Hub</option>
         <option name="continent" type="string">Continent</option>
         <option name="country" type="string">Country</option>
         <option name="campus" type="string">Campus</option>
         <option name="city" type="string">City</option>
         <option name="building" type="string">Building</option>
         <option name="room" type="string">Room</option>
         <option name="rack" type="string">Rack</option>
         <option name="desk" type="string">Desk</option>
         <option name="networkip" type="ipv4" conflicts="organization hub continent country campus city building room rack desk">Network IP address</option>
      </optgroup>
      <transport method="post" path="service/%(service)s/instance/%(instance)s/command/unmap" />
   </command>

   <command name="del_host">
      Delete a host. This will fail if the host is being used to provide
      any services. Once the host has been deleted, all configuration data will
      be discarded and the host will be unable to rebuild.
      <optgroup name="del_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
      </optgroup>
      <transport method="delete" path="host/%(hostname)s" />
   </command>

   <command name="del_windows_host">
      Delete a host with the windows archetype.  This is a simple wrapper
      over del_host and only exists for handling entitlements.
      <optgroup name="del_windows_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
      </optgroup>
      <transport method="delete" path="windows_host/%(hostname)s" />
   </command>

   <command name="pxeswitch">
      Change the way the host boots.  At boot, the host may either reboot
      from local disk (--localboot), or it can reinstall (--install). The
      pxeswitch switches the default by changing the configuration on the
      host's bootserver.
      After a successful installation, the host will automatically pxeswitch
      itself back to local disk booting.
      The --configure option forces a reset of the configuration files for this host on
      the bootserver.
      The --list option can be used to change multiple hosts at the same time. The
      argument to --list is a filename containing a list of hostnames, one per line.
      All hosts will be set to the same status.
      <optgroup name="pxeswitch_opts" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="list">Host name</option>
         <option name="list" type="list" conflicts="hostname">file containing hostnames</option>
      </optgroup>
      <optgroup name="pxeswitch_action" mandatory="False" fields="any">
         <option name="status" type="flag" conflicts="localboot install firmware blindbuild rescue">display the current status of how the host will boot</option>
         <option name="configure" type="boolean" default="True">(re)initialize the pxeswitch configuration (the default)</option>
         <option name="localboot" type="flag" conflicts="install firmware blindbuild rescue">set the host to boot from local disk</option>
         <option name="install" type="flag" conflicts="localboot firmware blindbuild rescue">set the host to install from the network at next reboot</option>
         <option name="firmware" type="flag" conflicts="localboot install blindbuild rescue">set the host to boot its firmware image</option>
         <option name="blindbuild" type="flag" conflicts="localboot install firmware rescue">set the host to boot a blindbuild livecd image</option>
         <option name="rescue" type="flag" conflicts="localboot install firmware blindbuild">set the host to boot a rescue image</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/pxeswitch" />
      <transport trigger="list" method="post" path="command/pxeswitch/list" />
   </command>

   <command name="reconfigure">
      re-build the configuration settings for the specified host, using
      all of the current service bindings and definitions.  This
      "flushes" any configuration settings, by: regenerating the host
      profile; checking all service bindings against the service maps;
      forcing the bootservers to rebuild their state for this host;
      notifying all datawarehouse tools that the host has been updated;
      notifying the host that it's configuration has been updated. These
      tasks are done even if there is no real change in configuration.
      It's the same as just running "make_aquilon" again, with the
      original arguments.  Any services that are not listed as required
      for the personality or the archetype are dropped unless the
      --keepbindings flag is specified.
      <optgroup name="reconfigure_options" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="hostlist list memberof">Host name</option>
         <option name="hostlist" type="list" conflicts="hostname list memberof">[Deprecated] File with one host per line</option>
         <option name="list" type="list" conflicts="hostname hostlist memberof">File with one host per line</option>
         <option name="membersof" type="string" conflicts="hostlist list hostname">Hosts which are members of the specified cluster</option>
      </optgroup>
      <optgroup name="reconfigure_optional" mandatory="False">
         <option name="osname" type="string">name of the OS to assign to the host (linux, windows, esx, etc.)</option>
         <option name="osversion" type="string">version of the OS</option>
         <option name="archetype" type="string">Archetype of the personality</option>
         <option name="personality" type="string">Personality of the host</option>
         <option name="buildstatus" type="string">Update host buildstatus to 'build' or 'ready'</option>
         <option name="keepbindings" type="boolean">Preserve service bindings that are not required</option>
         <option name="os" type="string">[Deprecated] OS to assign to host</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/reconfigure" />
      <transport trigger="list" method="post" path="command/reconfigure/list" />
      <transport trigger="hostlist" method="post" path="command/reconfigure/hostlist" />
      <transport trigger="membersof" method="post" path="command/reconfigure/membersof/%(membersof)s" />
   </command>

   <command name="change_status">
      Update the buildstatus for a host/cluster and recompile its profile.
      This command does not verify the service bindings of the host or cluster.

      Changing the buildstatus may cause the configuration to be different
      (for example, while hosts are in "build" status, they are not available
      for general login access) and so any affected profiles will be recompiled.

      Changing a cluster buildstatus may cause the member hosts to also change their
      buildstatus.
      <optgroup name="change_status_options" mandatory="True" fields="all">
         <optgroup name='what_to_change' mandatory="True" fields="any">
                <option name="hostname" type="string">Host name</option>
                <option name="cluster" type="string">Cluster name</option>
         </optgroup>
         <option name="buildstatus" type="string">The new value of the buildstatus</option>
      </optgroup>
      <transport method="put" path="host/%(hostname)s/buildstatus/%(buildstatus)s" />
      <transport method="put" trigger="cluster" path="cluster/%(cluster)s/buildstatus/%(buildstatus)s" />
   </command>

   <command name="reset_advertised_status">
      Reset the advertised status for a host to build and recompile its profile.
      This command does not verify the service bindings of the host. The advertise
      status will automaticlaly flip to true once the host status changes to 'ready'.

      Changing the advertised may cause the configuration to be different
      (for example, while hosts are in "build" status, they are not available
      for general login access) and so any affected profiles will be recompiled.

      <optgroup name="reset_advertised_status" mandatory="True" fields="all">
         <optgroup name='what_to_change' mandatory="True" fields="any">
                <option name="hostname" type="string">Host name</option>
                <option name="list" type="list" conflicts="hostname">File with one host per line</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/resetadvertisedstatus" />
      <transport trigger="list" method="post" path="command/resetadvertisedstatus/list" />
   </command>


   <command name="add_domain">
      Add a new server-managed template domain.  Updates to these domains
      can only be made through the broker.  A domain can either allow new
      content to be merged in or can track another domain.

      A tracking domain is useful because it can be rolled back to a
      previous state quickly.  Such a domain is initialized to point to
      the same commit as the branch it is tracking.

      If a domain is not directly tracking another it still needs to
      be initialized to start somewhere.  This is specified with the
      start option.  The default is the head of the prod domain.

      Either type of domain can be used with the "manage" command in
      order to assign some hosts to the domain and run complete tests.
      <p/>
      Setting the --change_manager flag will require a valid TCM or
      Service Now id passed into the "aq deploy" command's --justification
      option for the deploy to work.
      <optgroup name="add domain mandatory" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the new domain</option>
      </optgroup>
      <optgroup name="add domain optional" mandatory="False">
         <option name="track" type="string" conflicts="start">Branch to track</option>
         <option name="start" type="string" conflicts="track">Branch to use as a starting point (default: prod)</option>
         <option name="comments" type="string">Comments</option>
         <option name="change_manager" type="boolean">Require a change manager for the domain</option>
      </optgroup>
      <transport method="put" path="domain/%(domain)s" />
   </command>

   <command name="update_archetype">
      Update the meta-information for an archetype.  If the compilable flag
      is not given the attribute will be set to false for the archetype.

      <optgroup name="update_archetype_mandatory" mandatory="True" fields="all">
         <option name="archetype" type="string">Name of the archetype</option>
      </optgroup>
      <optgroup name="update_archetype_options" mandatory="False">
         <option name="compilable" type="boolean">Can profiles be compiled?</option>
         <option name="description" type="string">A human-readable description of the archetype name</option>
         <option name="cluster_type" type="string">Only for cluster archetypes - what type of cluster is this?</option>
      </optgroup>
      <transport method="post" path="archetype/%(archetype)s" />
   </command>

   <command name="update_branch">
      Update the meta-information for a template branch.  This includes
      comments about the domain, the version of the pan compiler to use,
      and whether to automatically sync deployed or published changes
      to tracking domains.
      <p/>
      The only value allowed right now for --change_manager is "tcm", which
      means "aq deploy" requires a valid TCM.
      <optgroup name="update_branch_mandatory" mandatory="True" fields="all">
         <option name="branch" type="string">Name of the template branch (domain or sandbox)</option>
      </optgroup>
      <optgroup name="update_branch_options" mandatory="True" fields="any">
         <option name="comments" type="string">Comments on the branch</option>
         <option name="compiler_version" type="string">Version of panc to use</option>
         <option name="autosync" type="boolean">Set the autosync flag</option>
         <option name="change_manager" type="boolean">Require a change manager for the domain</option>
      </optgroup>
      <transport method="post" path="branch/%(branch)s" />
   </command>

   <command name="del_domain">
      Removes the specified template domain.  This will fail if there are
      hosts still being managed by the domain: you must use the "manage"
      command to reassign those hosts to other domains.
      <optgroup name="del_domain_options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the domain to be deleted</option>
      </optgroup>
      <transport method="delete" path="domain/%(domain)s" />
   </command>

   <command name="add_sandbox">
      Add a new template sandbox.  This is for testing changes to the
      templates.  The new sandbox will have no hosts when it is freshly
      created and you should use the "manage" command in order to assign
      some hosts to the sandbox in order to run complete tests.

      After adding the sandbox branch on the broker the client will
      automatically attempt to run a 'get' for the user.  This can be
      disabled with the --noget flag.
      <optgroup name="add sandbox mandatory" mandatory="True" fields="all">
         <option name="sandbox" type="string">Name of the new sandbox</option>
      </optgroup>
      <optgroup name="add sandbox optional" mandatory="False">
         <option name="start" type="string">Branch to use as a starting point (default: prod)</option>
         <option name="get" type="boolean" default="False">Create the user-controlled sandbox automatically.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="sandbox/command/add" expect="sandbox"/>
   </command>

   <command name="get">
      Create a working copy of the templates in a sandbox.  The
      templates will be placed in a shared location that the broker
      will still be able to read.
      <optgroup name="get mandatory" mandatory="True" fields="all">
         <option name="sandbox" type="string">Name of the sandbox</option>
      </optgroup>
      <transport method="post" path="sandbox/command/get" expect="sandbox"/>
   </command>

   <command name="publish">
      Upload the template changes in the current directory to the
      specified template sandbox branch.  This makes the changes
      available to others for review and for the deploy command.
      The manage and compile commands can be used before running
      publish to test the changes.
      <optgroup name="publish options" mandatory="True" fields="all">
         <option name="branch" type="string">Name of the sandbox branch to update</option>
      </optgroup>
      <optgroup name="publish optional" mandatory="False">
         <option name="sync" type="boolean" default="True">Automatically sync tracking domains</option>
         <option name="rebase" type="flag">Allow rebasing the branch</option>
      </optgroup>
      <transport method="post" path="branch/%(branch)s/command/publish" custom="create_bundle" expect="command"/>
   </command>

   <command name="deploy">
      Take a template branch as a source (the name of either a domain or
      a sandbox) and deploy its changes to the target domain specified.
      If the target domain had been marked as invalid for syncing because
      of a previous rollback that flag is cleared.
      If using the nosync option follow this with the sync command to
      pull the changes into any production domains.
      <p/>
      If changes to the target branch are under change manager control,
      then the --justification must be provided in the form of
      "tcm=NNNNNNNNN" or "sn=XXXNNNNN", where either a valid TCM or
      Service Now id is provided.
      <optgroup name="deploy options" mandatory="True" fields="all">
         <option name="source" type="string">Name of the branch (domain or sandbox) with changes</option>
         <option name="target" type="string">Name of the target domain</option>
      </optgroup>
      <optgroup name="deploy optional" mandatory="False">
         <option name="sync" type="boolean" default="True">Automatically sync tracking domains</option>
         <option name="dryrun" type="boolean">Attempt a test merge and run tests without saving the merge result</option>
         <option name="comments" type="string">Comments to include in the merge commit</option>
	 <option name="justification" type="string">Extra authorization tokens (e.g. TCM number) to validate the request</option>
      </optgroup>
      <transport method="post" path="command/deploy" />
   </command>

   <command name="validate">
      Assert that a branch (a sandbox or a domain) can by sync'd into
      a tracking domain.
      Typically this is used after a rollback has been issued on a
      tracking domain.
      <optgroup name="validate options" mandatory="True" fields="all">
         <option name="branch" type="string">Name of domain or sandbox</option>
      </optgroup>
      <optgroup name="validate optional" mandatory="False" fields="all">
         <option name="comments" type="string">Provide a comment as to why the branch is valid</option>
      </optgroup>
      <transport method="post" path="branch/%(branch)s/command/validate" />
   </command>

   <command name="rollback">
      Set a tracking domain back to a known good state.  Any valid
      git reference (usually the SHA1 hash commit id, can be
      abbreviated) can be given.  Alternately the lastsync option will
      roll back to the commit in use before the domain was last sync'd.
      The tracked domain will be flagged to not allow a sync until a
      validate has been run or fixes have been deployed.
      <optgroup name="rollback options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of domain or sandbox</option>
         <optgroup name="ref options" mandatory="True" fields="any">
            <option name="ref" type="string" conflicts="lastsync">Any valid git reference to a previous commit in the branch</option>
            <option name="lastsync" type="flag" conflicts="ref">Use the reference stored in AQDB of the commit in use before the last sync</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/rollback" />
   </command>

   <command name="del_sandbox">
      Removes the specified sandbox branch.  This will fail if there are
      hosts still being managed by the sandbox: you must use the "manage"
      command to reassign those hosts to other domains.

      This will not remove user-owned working directories.  A reminder
      will be issued to clean up any such directories.
      <optgroup name="del_sandbox_options" mandatory="True" fields="all">
         <option name="sandbox" type="string">Name of the sandbox to be deleted</option>
      </optgroup>
      <transport method="post" path="sandbox/command/delete" />
   </command>

   <command name="manage">
      Take a host and make it build its configuration using the specified
      template domain or sandbox.  This allows you to test building hosts
      using alternate templates, or to move a host back to a default
      production domain once testing has completed.
      <optgroup name="manage options" mandatory="True" fields="all">
         <optgroup name="host_or_cluster" fields="any" mandatory="True">
            <option name="hostname" type="string">Name of the host to manage</option>
            <option name="cluster" type="string">Name of the cluster to manage</option>
         </optgroup>
         <optgroup name="domain_or_sandbox" fields="any" mandatory="True">
            <option name="domain" type="string" conflicts="sandbox">Name of the domain</option>
            <option name="sandbox" type="string" conflicts="domain">Name of the sandbox (given as 'author/branch')</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="command/manage_hostname" trigger="hostname" />
      <transport method="post" trigger="cluster" path="command/manage_cluster" />
   </command>

   <command name="cat">
      Prints the content of the plenary template in use for any one of the
      given options.  All are exclusive, except --instance and/or --default
      also require --service.
      The --generate option allows you to see what the body of a plenary template
      might look like if it were to be generated right now. This is useful if the
      plenary template does not exist yet because it cannot be compiled. Note
      that template generated on-demand in this way will be incomplete
      (especially if it cannot be compiled) and is purely provided for debugging.
      <optgroup name="cat_selector" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname cluster service instance default nasinfo city">Name of the machine</option>
         <option name="hostname" type="string" conflicts="machine cluster service instance default nasinfo city">Name of the host</option>
         <option name="cluster" type="string" conflicts="hostname machine service instance default nasinfo city">Name of the cluster</option>
         <option name="service" type="string" conflicts="hostname machine cluster nasinfo city">Name of the service</option>
         <option name="nasinfo" type="string" conflicts="hostname machine cluster service instance default city">Show the default client config for the service/instance</option>
         <option name="city" type="string" conflicts="hostname machine cluster service instance default nasinfo">Name of the city</option>
      </optgroup>
      <optgroup name="cat_options" mandatory="False" fields="any">
         <option name="default" type="flag" conflicts="hostname machine cluster nasinfo city">Show the default client config for the service/instance</option>
         <option name="server" type="flag" conflicts="hostname machine cluster nasinfo city">Show the server config for the service/instance</option>
         <option name="data" type="flag" conflicts="machine service nasinfo city">Show the data template for the host/cluster</option>
         <option name="instance" type="string" conflicts="hostname machine cluster nasinfo city">Name of the service instance</option>
         <option name="generate" type="boolean">Show the plenary template as it would be generated</option>
      </optgroup>
      <optgroup name="cat_resource_options" mandatory="False" fields="any">
         <option name="resourcegroup" type="string" conflicts="machine service instance default nasinfo data">Name of a resource group</option>
         <option name="application" type="string" conflicts="machine service instance default nasinfo data">Name of an application</option>
         <option name="filesystem" type="string" conflicts="machine service instance default nasinfo data">Name of a file system</option>
         <option name="hostlink" type="string" conflicts="machine service instance default nasinfo data">Name of a hostlink</option>
         <option name="intervention" type="string" conflicts="machine service instance default nasinfo data">Name of an intervention</option>
         <option name="reboot_intervention" type="string" conflicts="machine service instance default nasinfo data">Name of a reboot intervention</option>
         <option name="reboot_schedule" type="string" conflicts="machine service instance default nasinfo data">Name of a reboot schedule</option>
      </optgroup>
      <transport trigger="machine" method="get" path="machine/%(machine)s/plenary" />
      <transport trigger="hostname" method="get" path="host/%(hostname)s/plenary" />
      <transport trigger="cluster" method="get" path="cluster/any/%(cluster)s/plenary" />
      <transport trigger="service" method="get" path="service/%(service)s/plenary" />
      <transport trigger="instance" method="get" path="service/%(service)s/instance/%(instance)s/plenary" />
      <transport trigger="nasinfo" method="get" path="nasinfo/%(nasinfo)s/plenary" />
      <transport trigger="city" method="get" path="city/%(city)s/plenary" />
   </command>

   <command name="sync">
      Use this to bring the broker's working copy of a template branch up to
      date with the information in template-king.
      A sync is automatically run for any domains tracking a deploy
      unless the nosync option was used.
      <optgroup name="sync mandatory" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the domain</option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/sync" />
   </command>

   <command name="add_location">
      Create a new location within the database, which can then be used to place
      hosts and within service maps. Names of all locations are globally unique.
      For example, you can only have one city 'ln' anywhere, and only one chassis called "np3c5".
      <optgroup name="add_location_opts" mandatory="True" fields="all">
         <option name="name" type="string">Short name of new location</option>
         <option name="fullname" type="string">Full/descriptive name of new location</option>
         <option name="type" type="string">Location type</option>
         <option name="parentname" type="string">Short name of parent</option>
         <option name="parenttype" type="string">Location type of parent</option>
      </optgroup>
      <optgroup name="add_location_optional" mandatory="False">
         <option name="comments" type="string">Comments about the location</option>
      </optgroup>
      <transport method="put" path="location/generic/%(type)s/%(name)s" />
   </command>

   <command name="show_location">
      Shows all locations of a given type
      or information about a specific location type and name.
      <p/>
      Supported options for --format: raw, csv, proto.
      <optgroup name="show_location_opts" mandatory="True" fields="all">
         <option name="type" type="string">Location type</option>
      </optgroup>
      <optgroup name="show_location_optional" mandatory="False" fields="all">
         <option name="name" type="string">Location name</option>
      </optgroup>
      <transport trigger="type" method="get" path="location/%(type)s" />
      <transport trigger="name" method="get" path="location/%(type)s/%(name)s" />
   </command>

   <command name="del_location">
      Remove a location from the database. The command will fail if there
      are any hosts at that location, or if the location is used within any service maps.
      <optgroup name="del_location_opts" mandatory="True" fields="all">
         <option name="name" type="string">Short name of new location</option>
         <option name="type" type="string">Location type</option>
      </optgroup>
      <transport method="delete" path="location/generic/%(type)s/%(name)s" />
   </command>

   <command name="add_chassis">
      Add a new chassis to the database.  A chassis can contain multiple blades. Management tasks for the blades are typically performed by connecting to the chassis itself, and so the chassis name must exist within DNS.
      <optgroup name="add_chassis_input" mandatory="True" fields="all">
         <option name="chassis" type="string">FQDN name of the new chassis</option>
         <option name="rack" type="string">Name of the rack location for this chassis</option>
	 <option name="model" type="string">Model of chassis to create. Use 'show model --type chassis' to see a list of valid models</option>
      </optgroup>
      <optgroup name="optional_opts">
	 <option name="ip" type="ipv4">IP address of the chassis</option>
	 <option name="interface" type="string">Interface name (like oa)</option>
	 <option name="mac" type="mac">MAC address of the interface</option>
	 <option name="label" type="string">Hardware label. If not specified, chassis name minus the DNS domain is used.</option>
	 <option name="vendor" type="string">Chassis vendor. Needed if the model name is not unique</option>
	 <option name="serial" type="string">serial number</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="chassis/%(chassis)s" />
   </command>

   <command name="show_chassis">
      Show the chassis list, or details about a particular chassis.
      <p/>
      The --missing option will list aq commands to add chassis information for
      blade machines that are not currently in a chassis.
      <optgroup name="show_chassis_opts" mandatory="True" fields="any">
         <option name="chassis" type="string" conflicts="all">Chassis name</option>
         <option name="all" type="flag" conflicts="chassis">Select all</option>
         <option name="missing" type="flag" conflicts="chassis">Show blades that has no chassis</option>
      </optgroup>
      <transport trigger="all" method="get" path="chassis" />
      <transport trigger="chassis" method="get" path="chassis/%(chassis)s" />
      <transport trigger="missing" method="get" path="find/missing_chassis" />
   </command>

   <command name="del_chassis">
      Delete a chassis.
      <p/>
      If the chassis has populated slots, then the --force flag can be used to
      remove all machines from the chassis before deleting the chassis.
      <optgroup name="del_chassis_opts" mandatory="True" fields="all">
         <option name="chassis" type="string">Chassis name</option>
      </optgroup>
      <optgroup name="del_chassis_optional" mandatory="False" fields="any">
         <option name="clear_slots" type="flag">Remove all machines first</option>
      </optgroup>
      <transport method="delete" path="chassis/%(chassis)s" />
   </command>

   <command name="update_chassis">
      Update chassis information.  Requires the chassis name.  All
      other fields can be updated.
      <optgroup name="update_chassis_mandatory" mandatory="True" fields="all">
         <option name="chassis" type="string">Chassis name</option>
      </optgroup>
      <optgroup name="update_chassis_optional" mandatory="False">
         <option name="model" type="string">Chassis model</option>
         <option name="rack" type="string">Rack name</option>
         <option name="ip" type="ipv4">Primary IP address</option>
	 <option name="vendor" type="string">Chassis vendor. Needed if the model name is not unique</option>
	 <option name="serial" type="string">Serial Number</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="chassis/%(chassis)s" />
   </command>

   <command name="add_rack">
      Add a new rack to the database.  To add a rack named dd120 on tile H13,
      use --building=dd --rackid=120 --row=H --column=13.  The rackid
      option can also be prefixed by building name, so using
      --building=dd --rackid=dd120 --row=H --column=13 would also work.
      See also add_location.
      <optgroup name="add_rack_input" mandatory="True" fields="all">
         <option name="rackid" type="string">Name of the new rack, or just the id number</option>
         <option name="row" type="string">Row of the tile location</option>
         <option name="column" type="string">Column of the tile location</option>
         <optgroup name="add_rack_parent" mandatory="True" fields="any">
            <option name="building" type="string" conflicts="room">Name of the building that houses the rack</option>
            <option name="room" type="string" conflicts="building">Name of the room that houses the rack</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_rack_to_building/%(building)s/%(rackid)s" />
      <transport method="put" trigger="room" path="location/add_rack_to_room/%(room)s/%(rackid)s" />
   </command>

   <command name="update_rack">
      Update the row and column parameters for a rack.
      <optgroup name="update_rack_input" mandatory="True" fields="all">
         <option name="rack" type="string">Name of the rack</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="row" type="string">Row of the tile location</option>
         <option name="column" type="string">Column of the tile location</option>
         <option name="room" type="string" conflicts="clearroom">Name of the room that houses the rack</option>
         <option name="clearroom" type="boolean" conflicts="room">Clear room information for the rack</option>
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
         <option name="default_dns_domain" type="string">Default DNS domain for new machines</option>
      </optgroup>
      <transport method="post" path="location/rack/%(rack)s" />
   </command>

   <command name="show_rack">
      Show the rack list, or details about a particular rack.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_rack_opts" mandatory="True" fields="any">
         <option name="rack" type="string" conflicts="all">rack name</option>
         <option name="all" type="flag" conflicts="rack">all</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/rack" />
      <transport trigger="rack" method="get" path="location/rack/%(rack)s" />
   </command>

   <command name="del_rack">
      Delete a rack. See also del_location.
      <optgroup name="del_rack_opts" mandatory="True" fields="all">
         <option name="rack" type="string">rack name</option>
      </optgroup>
      <transport method="delete" path="location/rack/%(rack)s" />
   </command>

   <command name="add_building">
      Add a new building to the database. See also add_location.
      <optgroup name="add_building_input" mandatory="True" fields="all">
         <option name="building" type="string">Name of the new building</option>
         <option name="address" type="string">The building's address</option>
         <option name="city" type="string">Name of the city that contains the building</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/building/%(building)s" />
   </command>

   <command name="update_building">
      Update the address parameter and city for a building.
      <optgroup name="update_building_input" mandatory="True" fields="all">
         <option name="building" type="string">Name of the building</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="address" type="string">Address of the building</option>
         <option name="city" type="string">Name of the city the building is in</option>
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="default_dns_domain" type="string">Default DNS domain for new machines</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="location/building/%(building)s" />
   </command>

   <command name="show_building">
      Show the building list, or details about a particular building.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_building_opts" mandatory="True" fields="any">
         <option name="building" type="string" conflicts="all">building name</option>
         <option name="all" type="flag" conflicts="building">Select all</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/building" />
      <transport trigger="building" method="get" path="location/building/%(building)s" />
   </command>

   <command name="del_building">
      Delete a building. See also del_location.
      <optgroup name="del_building_opts" mandatory="True" fields="all">
         <option name="building" type="string">building name</option>
      </optgroup>
      <transport method="delete" path="location/building/%(building)s" />
   </command>

   <command name="add_campus">
      Add a new campus to the database. See also add_location.
      <optgroup name="add_campus_input" mandatory="True" fields="all">
         <option name="campus" type="string">Name of the new campus</option>
         <option name="country" type="string">Name of the country that contains the campus</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/campus/%(campus)s" />
   </command>

   <command name="del_campus">
      Delete a campus. See also del_location.
      <optgroup name="del_campus_opts" mandatory="True" fields="all">
         <option name="campus" type="string">campus name</option>
      </optgroup>
      <transport method="delete" path="location/campus/%(campus)s" />
   </command>

   <command name="add_room">
      Add a new room to the database. See also add_location.
      <optgroup name="add_room_input" mandatory="True" fields="all">
         <option name="room" type="string">Name of the new room</option>
         <option name="building" type="string">Name of the building that contains the room</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/room/%(room)s" />
   </command>

   <command name="show_room">
      Show the room list, or details about a particular room.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_room_opts" mandatory="True" fields="any">
         <option name="room" type="string">room name</option>
         <option name="all" type="flag">show all</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/room" />
      <transport trigger="room" method="get" path="location/room/%(room)s" />
   </command>

   <command name="del_room">
      Delete a room. See also del_location.
      <optgroup name="del_room_opts" mandatory="True" fields="all">
         <option name="room" type="string">room name</option>
      </optgroup>
      <transport method="delete" path="location/room/%(room)s" />
   </command>

   <command name="show_campus">
      Show the list of campuses, or details about a particular campus.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_campus_opts" mandatory="True" fields="any">
         <option name="campus" type="string" conflicts="all">campus name</option>
         <option name="all" type="flag" conflicts="campus">show all campuses</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/campus" />
      <transport trigger="campus" method="get" path="location/campus/%(campus)s" />
   </command>

   <command name="add_city">
      Add a new city to the database. See also add_location.
      <p/>
      Cities have a plenary template named site/$region/$city/config. The timezone of the city will be available in this template as the global variable TIMEZONE.
      <optgroup name="add_city_options" mandatory="True" fields="all">
         <option name="city" type="string">Name of the new city</option>
         <option name="timezone" type="string">Timezone of the city (e.g. Europe/London)</option>
      </optgroup>
      <optgroup name="add_city_location_options" mandatory="True" fields="any">
         <option name="country" conflicts="campus" type="string">Name of the country that contains the city</option>
         <option name="campus" conflicts="country" type="string">Campus</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/city/%(city)s" />
   </command>

   <command name="update_city">
      Update the timezone of an existing city. See also add_city.
      <optgroup name="update_city_options" mandatory="True" fields="all">
         <option name="city" type="string">Name of the city</option>
      </optgroup>
      <optgroup name="optional_opts" mandatory="False" fields="any">
         <option name="timezone" type="string">Timezone of the city (e.g. Europe/London)</option>
         <option name="campus" type="string">Campus (should be in the same hub)</option>
         <option name="default_dns_domain" type="string">Default DNS domain for new machines</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="location/city/%(city)s" />
   </command>

   <command name="show_city">
      Show the list of cities, or details about a particular city.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_city_opts" mandatory="True" fields="any">
         <option name="city" type="string" conflicts="all">city name</option>
         <option name="all" type="flag" conflicts="city">show all cities</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/city" />
      <transport trigger="city" method="get" path="location/city/%(city)s" />
   </command>

   <command name="del_city">
      Delete a city. See also del_location.
      <optgroup name="del_city_opts" mandatory="True" fields="all">
         <option name="city" type="string">city name</option>
      </optgroup>
      <transport method="delete" path="location/city/%(city)s" />
   </command>

   <command name="add_country">
      Add a new country to the database. See also add_location.
      <optgroup name="add_country_options" mandatory="True" fields="all">
         <option name="country" type="string">Name of the new country</option>
         <option name="continent" type="string">Name of the continent that contains the country</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/country/%(country)s" />
   </command>

   <command name="show_country">
      Show the list of countries, or details about a particular country.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_country_opts" mandatory="True" fields="any">
         <option name="country" type="string" conflicts="all">country name</option>
         <option name="all" type="flag" conflicts="country">show all countries</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/country" />
      <transport trigger="country" method="get" path="location/country/%(country)s" />
   </command>

   <command name="del_country">
      Delete a country. See also del_location.
      <optgroup name="del_country_opts" mandatory="True" fields="all">
         <option name="country" type="string">country name</option>
      </optgroup>
      <transport method="delete" path="location/country/%(country)s" />
   </command>

   <command name="add_continent">
      Add a new continent to the database. See also add_location.
      <optgroup name="add_continent_options" mandatory="True" fields="all">
         <option name="continent" type="string">Name of the new continent</option>
         <option name="hub" type="string">Name of the hub, which the continent belongs to</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/continent/%(continent)s" />
   </command>

   <command name="show_continent">
      Show the list of continents, or details about a particular continent.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_continent_opts" mandatory="True" fields="any">
         <option name="continent" type="string" conflicts="all">continent name</option>
         <option name="all" type="flag" conflicts="continent">show all continents</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/continent" />
      <transport trigger="continent" method="get" path="location/continent/%(continent)s" />
   </command>

   <command name="del_continent">
      Delete a continent. See also del_location.
      <optgroup name="del_continent_opts" mandatory="True" fields="all">
         <option name="continent" type="string">continent name</option>
      </optgroup>
      <transport method="delete" path="location/continent/%(continent)s" />
   </command>

   <command name="add_organization">
      Add a new organization.
      <optgroup name="add_org_options" mandatory="True" fields="all">
         <option name="organization" type="string">Name of the new organization</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/organization/%(organization)s" />
   </command>

   <command name="del_organization">
      Delete an organization. This will fail if the organization contains
      any hubs.
      <optgroup name="del_org_options" mandatory="True" fields="all">
         <option name="organization" type="string">Name of the organization</option>
      </optgroup>
      <transport method="delete" path="location/organization/%(organization)s" />
   </command>

   <command name="show_organization">
      Show an organization.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_org_options" mandatory="True" fields="any">
         <option name="organization" type="string" conflicts="all">Name of the organization</option>
         <option name="all" type="flag" conflicts="organization">Show all organizations</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/organization" />
      <transport trigger="organization" method="get" path="location/organization/%(organization)s" />
   </command>

   <command name="add_hub">
      Add a new hub to the database. See also add_location.
      <optgroup name="add_hub_options" mandatory="True" fields="all">
         <option name="hub" type="string">Name of the new hub</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive (region) name</option>
         <option name="organization" type="string">The owning organization of the hub</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/hub/%(hub)s" />
   </command>

   <command name="show_hub">
      Show the list of hubs, or details about a particular hub.
      <p/>
      Supported options for --format: raw, csv, proto.
      <p/>
      <optgroup name="show_hub_opts" mandatory="True" fields="any">
         <option name="hub" type="string" conflicts="all">hub name</option>
         <option name="all" type="flag" conflicts="hub">Show all hubs</option>
      </optgroup>
      <transport trigger="all" method="get" path="location/hub" />
      <transport trigger="hub" method="get" path="location/hub/%(hub)s" />
   </command>

   <command name="del_hub">
      Delete a hub. See also del_location.
      <optgroup name="del_hub_opts" mandatory="True" fields="all">
         <option name="hub" type="string">hub name</option>
      </optgroup>
      <transport method="delete" path="location/hub/%(hub)s" />
   </command>

  <command name="add_archetype">
      Create an archetype.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="archetype" type="string">The name to create</option>
      </optgroup>
      <optgroup name="options">
         <option name="compilable" type="boolean" default='False'>Does this archetype produce profiles?</option>
         <option name="description" type="string">A human readable description of the archetype name</option>
         <option name="cluster_type" type="string">For cluster archetypes - what kind of cluster is this?</option>
      </optgroup>
      <transport method="put" path="archetype/%(archetype)s" />
  </command>

  <command name="del_archetype">
      Delete an archetype.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="archetype" type="string">The name to delete</option>
      </optgroup>
      <transport method="delete" path="archetype/%(archetype)s" />
  </command>


  <command name="add_personality">
      Create a personality. A default template will be created, however
      this default will be insufficient for real usage and will need to
      be edited in order to provide realistic information for such things as
      cost allocations, usage, etc.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="personality" type="string">The name to create</option>
         <option name="archetype" type="string">Which archetype to use</option>
      </optgroup>
      <optgroup name="add_personality_optional" mandatory="False">
         <option name="cluster_required" type="boolean" default='False'>Does this personality require hosts to be clustered?</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="personality/%(archetype)s/%(personality)s" />
  </command>

  <command name="add_vendor">
      Create a vendor definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="vendor" type="string">The name of the vendor</option>
      </optgroup>
      <optgroup name="add_vendor_optional" mandatory="False">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="vendor/%(vendor)s" />
  </command>

  <command name="del_vendor">
      Remove a vendor definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="vendor" type="string">The name of the vendor</option>
      </optgroup>
      <transport method="delete" path="vendor/%(vendor)s" />
  </command>

  <command name="show_vendor">
      Show currently defined vendors.
      <optgroup name="mandatory_options" mandatory="True" fields="any">
         <option name="vendor" type="string" conflicts="all">The name of the vendor</option>
         <option name="all" type="flag" conflicts="vendor">Show all vendors</option>
      </optgroup>
      <transport trigger="vendor" method="get" path="vendor/%(vendor)s" />
      <transport trigger="all" method="get" path="vendor"/>
  </command>

  <command name="add_os">
      Create an operating system definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="osname" type="string">The name of the operating system</option>
         <option name="osversion" type="string">The version of the operating system</option>
         <option name="archetype" type="string">Which archetype the OS is being added to</option>
      </optgroup>
      <optgroup name="add_os_optional" mandatory="False">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="os/%(osname)s/%(osversion)s/%(archetype)s" />
  </command>

  <command name="del_os">
      Delete an operating system definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="osname" type="string">The name of the operating system</option>
         <option name="osversion" type="string">The version of the operating system</option>
         <option name="archetype" type="string">Which archetype the OS is being deleted from</option>
      </optgroup>
      <transport method="delete" path="os/%(osname)s/%(osversion)s/%(archetype)s" />
  </command>

  <command name="show_os">
      Show an operating system definition.
      <optgroup name="show_os_opts" mandatory="True" fields="any">
         <option name="osname" type="string">The name of the operating system</option>
         <option name="osversion" type="string">The version of the operating system</option>
         <option name="archetype" type="string">The archetype to search within</option>
         <option name="all" type="flag">Show all operating systems</option>
      </optgroup>
      <transport method="get" path="os"/>
  </command>

  <command name="del_personality">
      Delete a personality. This command will fail if any hosts are currently
      using the personality.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="personality" type="string">The name to delete</option>
         <option name="archetype" type="string">Which archetype to use</option>
      </optgroup>
      <transport method="delete" path="personality/%(archetype)s/%(personality)s" />
  </command>

  <command name="update_personality">
      Updates personality information.
      <optgroup name="update_personality_mandatory" mandatory="True" fields="all">
         <option name="personality" type="string">The name to delete</option>
         <option name="archetype" type="string">Which archetype to use</option>
      </optgroup>
      <optgroup name="update_personality_opt" mandatory="False">
	 <option name="vmhost_capacity_function" type="string">Function for calculating VM host capacity units</option>
	 <option name="vmhost_overcommit_memory" type="float">Memory overcommit factor for VM hosts</option>
         <option name="cluster_required" type="boolean" default='False'>Does this personality require hosts to be clustered?</option>
      </optgroup>
      <transport method="post" path="personality/%(archetype)s/%(personality)s" />
  </command>

  <command name="show_personality">
      Show personality details.  Specifying both name and archetype will
      uniquely identify a personality.
      <p/>
      If the domain option is given that domain will be searched for
      information about the personality's thresholds.
      <optgroup name="show_personality_opts" mandatory="True" fields="any">
         <option name="personality" type="string" conflicts="all">personality name (same name may be in multiple archetypes)</option>
         <option name="archetype" type="string" conflicts="all">which archetype to use</option>
         <option name="all" type="flag" conflicts="personality archetype">all</option>
      </optgroup>
      <optgroup name="show_personality_optional" mandatory="False">
         <option name="domain" type="string" conflicts="sandbox">Domain to check for threshold information</option>
         <option name="sandbox" type="string" conflicts="domain">Name of the sandbox (given as 'author/branch')</option>
      </optgroup>
      <transport method="get" path="personality" />
  </command>

   <command name="make">
      Build a host configuration.  Any required services which are not bound
      will cause an implicit bind_client to occur.  Any services that
      are not listed as required for the personality or the archetype
      are dropped unless the --keepbindings flag is specified.  The host
      information will be compiled into a working configuration.  Any
      errors in creating the configuration will be printed to the screen
      and cause the command to fail.  If the configuration is
      successfully created, then the new configuration may be
      "advertised" to the host itself, to the data warehouse and to the
      bootservers, making the host ready to build.  If this is a new host, then
      The bootservers will
      put the host into "install" mode of pxeswitch.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name to make</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">name of the OS to assign to the host (linux, windows, esx, etc.)</option>
         <option name="osversion" type="string">version of the OS</option>
         <option name="archetype" type="string">Archetype of the host (defaults to aquilon)</option>
         <option name="personality" type="string">Personality of the host</option>
         <option name="buildstatus" type="string">Build Status can be updated to 'build' or 'ready'.</option>
         <option name="keepbindings" type="boolean">Preserve service bindings that are not required</option>
         <option name="os" type="string">[Deprecated] OS to assign to host</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/make" />
   </command>

   <command name="make_aquilon">
      Create an aquilon host.  Any required services which are not bound
      will cause an implicit bind_client to occur.  Any services that
      are not listed as required for the personality or the archetype
      are dropped unless the --keepbindings flag is specified.  The host
      information will be compiled into a working configuration.  Any
      errors in creating the configuration will be printed to the screen
      and cause the command to fail.  If the configuration is
      successfully created, then the new configuration will be
      "advertised" to the host itself, to the data warehouse and to the
      bootservers, making the host ready to build.  The bootservers will
      put the host into "install" mode of pxeswitch.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name to make</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">name of the OS to assign to the host (linux, windows, esx, etc.)</option>
         <option name="osversion" type="string">version of the OS</option>
         <option name="personality" type="string">Personality of the host</option>
         <option name="buildstatus" type="string">Build Status can be updated to 'build' or 'ready'.</option>
         <option name="keepbindings" type="boolean">Preserve service bindings that are not required</option>
         <option name="os" type="string">[Deprecated] OS to assign to host</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/make_aquilon" />
   </command>

   <command name="make_cluster">
      Build a cluster configuration.  Any cluster aligned services which
      are not bound will cause an implicit bind_cluster to occur.  Any
      services that are not listed as aligned for the cluster type
      are dropped unless the --keepbindings flag is specified.  The cluster
      information will be compiled into a working configuration.  Any
      errors in creating the configuration will be printed to the screen
      and cause the command to fail.  If the configuration is successfully
      created, then the new configuration may be "advertised" to the cluster
      itself, to the data warehouse and to the bootservers, making the
      cluster ready to build.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name to make</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="keepbindings" type="boolean">Preserve service bindings that are not marked as aligned</option>
      </optgroup>
      <transport method="post" path="cluster/any/%(cluster)s/command/make" />
   </command>

   <command name="add_machine">
      Create a new machine at a given location.
      <p/>
      The machine name can be auto-created based on a given prefix.  This
      makes the machine name generation and creation atomic.  See the
      search_next command for information on how the next number is
      determined.
      <p/>
      If the model was created with machine specifications (values for
      cpuname, cpuvendor, cpuspeed, cpucount, memory) they do not need
      to be given to this command - the model info will be used as a default.
      <p/>
      However, if the model does not have defaults, they all need to be given.
      <p/>
      If the hardware is virtual the --cluster option should be used to
      indicate the location indirectly.  Whether or not hardware is
      virtual is indicated by the machine type of the model.
      <optgroup name="add_machine_opts" mandatory="True" fields="all">
         <option name="model" type="string">machine model</option>
         <optgroup name="add_machine_name" mandatory="True" fields="any">
            <option name="machine" type="string" conflicts="prefix">machine name</option>
            <option name="prefix" type="string" conflicts="machine">machine prefix</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_machine_specs_opts" mandatory="False">
	 <option name="vendor" type="string">Machine vendor. Needed if the model name is not unique</option>
	 <option name="cpuname" type="string">cpu name</option>
	 <option name="cpuvendor" type="string">cpu vendor</option>
	 <option name="cpuspeed" type="int">cpu speed</option>
	 <option name="cpucount" type="int">cpu count</option>
	 <option name="memory" type="int">memory in MB</option>
      </optgroup>
      <optgroup name="add_machine_location_opts" mandatory="True" fields="any">
	 <optgroup name="add_machine_chassis_opts" fields="all">
            <option name="chassis" type="string">Chassis name</option>
            <option name="slot" type="int">Chassis slot</option>
         </optgroup>
         <option name="rack" type="string">Rack name</option>
         <option name="desk" type="string">Desk name</option>
         <optgroup name="add_machine_cluster_opts" fields="all">
            <option name="cluster" type="string" conflicts="chassis rack desk">Cluster name</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_machine_optional">
	 <option name="serial" type="string">Serial number</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="machine/%(machine)s" />
      <transport method="post" trigger="prefix" path="next_machine/%(prefix)s" />
   </command>

   <command name="update_machine">
      Update a machine by hardware name or hostname.
      <p/>
      Updating the model for a machine will not automatically update
      the machine to the new model's default specifications.  To do so, give
      the new information (cpu, count, memory) at the same time.
      <optgroup name="update_machine_opts" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname">machine name</option>
         <option name="hostname" type="string" conflicts="machine">fully qualified host name</option>
      </optgroup>
      <optgroup name="update_machine_opts" mandatory="False" fields="any">
         <option name="model" type="string">machine model</option>
         <option name="vendor" type="string">machine vendor</option>
         <option name="cpuname" type="string">cpu name</option>
         <option name="cpuvendor" type="string">cpu vendor</option>
         <option name="cpuspeed" type="int">cpu speed</option>
         <option name="cpucount" type="int">cpu count</option>
         <option name="memory" type="int">memory in MB</option>
         <option name="chassis" type="string">chassis name</option>
         <option name="slot" type="int">chassis slot</option>
         <option name="clearchassis" type="boolean">remove chassis and slot information</option>
         <option name="multislot" type="boolean">use to record machine as taking multiple slots in a chassis</option>
         <option name="rack" type="string">rack name</option>
         <option name="desk" type="string">desk name</option>
         <option name="serial" type="string">serial number</option>
         <option name="cluster" type="string">Cluster name</option>
         <option name="allow_metacluster_change" type="boolean">when changing clusters, allow the cluster to be in a different metacluster</option>
         <option name="ip" type="ipv4">New primary IP address</option>
      </optgroup>
      <transport method="post" trigger="hostname" path="host/%(hostname)s/command/update_hardware" />
      <transport method="post" path="machine/%(machine)s/command/update" />
   </command>

   <command name="show_machine">
      Show the hardware configuration of the named machine.
      <p/>
      Supported options for --format: raw, csv.
      <p/>
      The 'csv' format contains the following fields, in this order:
      Machine name, Rack, Building, Vendor name, Model name, Serial number,
      Interface name, Interface MAC address, Interface IP address.
      <p/>
      If the machine has multiple interfaces, then there will be a separate
      line for each.
      <optgroup name="show_machine_opts" mandatory="True" fields="any">
         <option name="machine" type="string">machine name</option>
	 <option name="all" type="flag" conflicts="machine">all</option>
         <optgroup name="show_machine_location_opts" mandatory="False">
            <option name="chassis" type="string">Chassis name</option>
	    <option name="slot" type="int">Chassis Slot</option>
            <option name="rack" type="string">Rack name</option>
            <option name="desk" type="string">Desk name</option>
         </optgroup>
         <option name="model" type="string">machine model</option>
         <option name="vendor" type="string">machine vendor</option>
         <option name="machine_type" type="string">machine type</option>
      </optgroup>
      <transport trigger="all" method="get" path="machine" />
      <transport trigger="machine" method="get" path="machine/%(machine)s" />
      <transport method="post" path="machine" />
   </command>

   <command name="del_machine">
      Delete the specified machine. This command will fail if the machine
      is being used: you must del_host before you can del_machine.
      <optgroup name="del_machine_opts" mandatory="True" fields="all">
         <option name="machine" type="string">machine name</option>
      </optgroup>
      <transport method="delete" path="machine/%(machine)s" />
   </command>

   <command name="add_tor_switch">
      Create a new Top-Of-Rack (TOR) network switch.
      <p/>
      This command is deprecated.  Please use the new add_switch.
      <optgroup name="add_tor_switch_opts" mandatory="True" fields="all">
         <option name="tor_switch" type="string">Switch name</option>
         <option name="model" type="string">Switch model</option>
      </optgroup>
      <optgroup name="add_tor_switch_location" mandatory="True" fields="any">
         <option name="rack" type="string" conflicts="building">Rack name</option>
         <optgroup name="add_tor_switch_new_rack" fields="all">
            <option name="rackid" type="string" conflicts="rack">Rack id/number</option>
            <option name="rackrow" type="string" conflicts="rack">Rack Row (letters only)</option>
            <option name="rackcolumn" type="string" conflicts="rack">Rack Column (numbers only)</option>
            <optgroup name="add_tor_switch_rack_parent" fields="any">
               <option name="building" type="string" conflicts="rack room">Building</option>
               <option name="room" type="string" conflicts="rack building">Room</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <optgroup name="add_tor_switch_primary" mandatory="False" fields="all">
         <option name="interface" type="string">Interface name (like xge49)</option>
         <option name="mac" type="mac">MAC address of the interface</option>
         <option name="ip" type="ipv4">IP address of the interface</option>
      </optgroup>
      <optgroup name="add_tor_switch_optional">
	 <option name="label" type="string">Hardware label. If not specified, chassis name minus the DNS domain is used.</option>
	 <option name="vendor" type="string">Switch vendor. Needed if the model name is not unique</option>
	 <option name="serial" type="string">Serial number</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="tor_switch/%(tor_switch)s" />
   </command>

   <command name="add_switch">
      Create a new network switch.
      <optgroup name="add_switch_mandatory" mandatory="True" fields="all">
         <option name="switch" type="string">Switch fully qualified name</option>
         <option name="model" type="string">Switch model</option>
         <option name="rack" type="string">Rack name</option>
         <option name="type" type="string">Switch type (tor, bor, agg)</option>
         <option name="ip" type="ipv4">IP address</option>
      </optgroup>
      <optgroup name="add_switch_optional" mandatory="False">
	 <option name="interface" type="string">Interface name (like xge49)</option>
	 <option name="mac" type="mac">MAC address of the interface</option>
	 <option name="label" type="string">Hardware label. If not specified, chassis name minus the DNS domain is used.</option>
	 <option name="vendor" type="string">Switch vendor. Needed if the model name is not unique</option>
	 <option name="serial" type="string">Serial Number</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="switch/%(switch)s" />
   </command>

   <command name="update_switch">
      Update network switch information.  Requires the switch name.  All
      other fields can be updated.
      <optgroup name="add_switch_mandatory" mandatory="True" fields="all">
         <option name="switch" type="string">Switch fully qualified name</option>
      </optgroup>
      <optgroup name="add_switch_optional" mandatory="False">
         <option name="model" type="string">Switch model</option>
         <option name="rack" type="string">Rack name</option>
         <option name="type" type="string">Switch type (tor, bor, agg)</option>
         <option name="ip" type="ipv4">IP address</option>
	 <option name="vendor" type="string">Switch vendor. Needed if the model name is not unique</option>
	 <option name="serial" type="string">Serial Number</option>
	 <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="switch/%(switch)s" />
   </command>

   <command name="show_tor_switch">
      Show the configuration information for the specified switch.
      <p/>
      This is deprecated.  Please use either show_switch or search_switch.
      <p/>
      Supported options for --format: raw, csv.
      <p/>
      The 'csv' format contains the following fields, in this order:
      FQDN, Rack, Building, Vendor name, Model name, Serial number,
      Interface name, Interface MAC address, Interface IP address.
      <p/>
      If the switch has multiple interfaces assigned, then there will be a
      separate line for each.
      <optgroup name="show_tor_switch_opts" mandatory="True" fields="any">
         <option name="tor_switch" type="string">ToR switch name</option>
         <option name="rack" type="string">Rack name</option>
         <option name="model" type="string">ToR switch model</option>
         <option name="vendor" type="string">ToR switch vendor </option>
         <option name="all" type="flag">show all</option>
      </optgroup>
      <transport trigger="tor_switch" method="get" path="tor_switch/%(tor_switch)s" />
      <transport method="get" path="find/tor_switch" />
   </command>

   <command name="show_switch">
      Show the configuration information for the specified switch.
      <p/>
      Supported options for --format: raw, csv.
      <p/>
      The 'csv' format contains the following fields, in this order:
      FQDN, Type, Rack, Building, Vendor name, Model name, Serial number,
      Interface name, Interface MAC address, Interface IP address.
      <p/>
      If the switch has multiple interfaces assigned, then there will be a
      separate line for each.
      <optgroup name="show_switch_opts" mandatory="True" fields="any">
         <option name="switch" type="string">switch fully qualified name</option>
         <option name="all" type="flag">show all</option>
      </optgroup>
      <transport trigger="switch" method="get" path="switch/%(switch)s" />
      <transport trigger="all" method="get" path="switch" />
   </command>

   <command name="search_switch">
      Find switches matching the given information.
      <p/>
      Note that location searches are inclusive.  That is, searching for a
      building will include all racks, rooms, etc. inside the building.  The
      --exact_location option can be used to override this behavior.
      <p/>
      Supported options for --format: raw, csv.
      <p/>
      The 'csv' format contains the following fields, in this order:
      FQDN, Type, Rack, Building, Vendor name, Model name, Serial number,
      Interface name, Interface MAC address, Interface IP address.
      <p/>
      If the switch has multiple interfaces assigned, then there will be a
      separate line for each.
      <optgroup name="search_switch_opts" mandatory="True" fields="any">
         <option name="switch" type="string">switch fully qualified name</option>
         <option name="type" type="string">Type (tor, bor, agg)</option>
         <option name="model" type="string">switch model</option>
         <option name="vendor" type="string">switch vendor </option>
         <optgroup name="search_switch_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
	 <option name="serial" type="string">serial number</option>
         <option name="exact_location" type="flag">match the location exactly</option>
         <option name="fullinfo" type="flag">show full information for the matching switches</option>
         <option name="all" type="flag">show all</option>
      </optgroup>
      <transport method="get" path="find/switch" />
   </command>

   <command name="del_tor_switch">
      Delete the specified TOR switch.
      <p/>
      This is deprecated.  Please use del_switch.
      <optgroup name="del_tor_switch_opts" mandatory="True" fields="all">
         <option name="tor_switch" type="string">tor_switch name</option>
      </optgroup>
      <transport method="delete" path="tor_switch/%(tor_switch)s" />
   </command>

   <command name="del_switch">
      Delete the specified switch.
      <optgroup name="del_switch_opts" mandatory="True" fields="all">
         <option name="switch" type="string">switch name</option>
      </optgroup>
      <transport method="delete" path="switch/%(switch)s" />
   </command>

   <command name="poll_tor_switch">
      Poll ToR switch for MAC information.
      <p/>
      This is deprecated.  Please use poll_switch.
      <optgroup name="poll_tor_switch_opts" mandatory="True" fields="any">
         <option name="tor_switch" type="string" conflicts="rack">tor_switch name</option>
         <option name="rack" type="string" conflicts="tor_switch">Rack name</option>
      </optgroup>
      <optgroup name="poll_tor_switch optional" mandatory="False" fields="any">
         <option name="clear" type="boolean">Clear any previously observed MACs before polling</option>
         <option name="vlan" type="boolean">Additionally poll for vlan/subnet mappings</option>
      </optgroup>
      <transport trigger="tor_switch" method="post" path="tor_switch/%(tor_switch)s/command/poll" />
      <transport method="post" path="old_poll/rack/%(rack)s" />
   </command>

   <command name="poll_switch">
      Poll switch for MAC information.
      <optgroup name="poll_switch_opts" mandatory="True" fields="any">
         <option name="switch" type="string" conflicts="rack">switch name</option>
         <option name="rack" type="string" conflicts="switch">Rack name</option>
      </optgroup>
      <optgroup name="poll_tor_switch optional" mandatory="False" fields="any">
         <option name="type" type="string">If polling a rack, poll only this type of switch</option>
         <option name="clear" type="boolean">Clear any previously observed MACs before polling</option>
         <option name="vlan" type="boolean">Additionally poll for vlan/subnet mappings</option>
      </optgroup>
      <transport trigger="switch" method="post" path="switch/%(switch)s/command/poll" />
      <transport method="post" path="poll/rack/%(rack)s" />
   </command>

   <command name="show_principal">
      Show the entitlements for a given username.
      <optgroup name="show_role_opts" mandatory="True" fields="any">
         <option name="principal" type="string" conflicts="all">User Principal to check</option>
         <option name="all" type="flag" conflicts="principal">Show all principals</option>
      </optgroup>
      <transport trigger="all" method="get" path="principal" />
      <transport trigger="principal" method="get" path="principal/%(principal)s" />
   </command>

   <command name="permission">
      Modify the entitlements for a user.
      <optgroup name="permission_opts" mandatory="True" fields="all">
         <option name="principal" type="string">User Principal (e.g. njw@is1.morgan) to change</option>
         <option name="role" type="string">Role to use</option>
      </optgroup>
      <optgroup name="permission_optional_opts">
         <option name="createuser" type="boolean">Create an entry for the user if one does not exist</option>
         <option name="createrealm" type="boolean">Create an entry for the realm if one does not exist (implies --createuser)</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="principal/%(principal)s/role" />
   </command>

   <command name="add_dns_environment">
      Add a new DNS Environment
      <optgroup name="dns_env_opts" mandatory="True" fields="all">
         <option name="dns_environment" type="string">The DNS environment name</option>
      </optgroup>
      <optgroup name="add_dns_env_optional" mandatory="False">
        <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="dns_environment/%(dns_environment)s" />
   </command>

   <command name="show_dns_environment">
      Display a DNS Environment
      <optgroup name="dns_env_opts" mandatory="True" fields="any">
         <option name="dns_environment" type="string">Name of the DNS environment</option>
         <option name="all" type="flag" conflicts="dns_domain">Show all DNS environments</option>
      </optgroup>
      <transport trigger="dns_environment" method="get" path="dns_environment/%(dns_environment)s" />
      <transport trigger="all" method="get" path="dns_environment" />
   </command>

   <command name="del_dns_environment">
      Delete a DNS Environment
      <optgroup name="dns_env_opts" mandatory="True" fields="all">
         <option name="dns_environment" type="string">The DNS environment name</option>
      </optgroup>
      <transport method="delete" path="dns_environment/%(dns_environment)s" />
   </command>

   <command name="add_dns_domain">
      Add a new DNS subdomain.
      <p/>
      The --restricted flag tells the broker that it does not have full control over
      the DNS domain, so commands that manipulate the DNS information are not allowed.
      Such operations must be performed by the tool that has full control over the
      domain (e.g. Active Directory).
      <optgroup name="add_dns_domain_options" mandatory="True" fields="all">
         <option name="dns_domain" type="string">Name of the new DNS domain</option>
      </optgroup>
      <optgroup name="add_dns_domain_optional_options" mandatory="False">
         <option name="comments" type="string">Comments</option>
         <option name="restricted" type="flag">Restrict direct DNS manipulation commands</option>
      </optgroup>
      <transport method="put" path="dns_domain/%(dns_domain)s" />
   </command>

   <command name="show_dns_domain">
      Show the configuration of the specified DNS domain. If --all is specified, then
      the configuration of all DNS domains will be output.
      <optgroup name="del_dns_domain_options" mandatory="True" fields="any">
         <option name="dns_domain" type="string" conflicts="all">Name of the DNS domain</option>
         <option name="all" type="flag" conflicts="dns_domain">Show all DNS domains</option>
      </optgroup>
      <transport trigger="dns_domain" method="get" path="dns_domain/%(dns_domain)s" />
      <transport trigger="all" method="get" path="dns_domain" />
   </command>

   <command name="del_dns_domain">
      Delete the named DNS subdomain.
      <optgroup name="del_dns_domain_options" mandatory="True" fields="all">
         <option name="dns_domain" type="string">Name of the DNS domain</option>
      </optgroup>
      <transport method="delete" path="dns_domain/%(dns_domain)s" />
   </command>

   <command name="update_dns_domain">
      Update the named DNS subdomain.
      <optgroup name="update_dns_domain_options" mandatory="True" fields="all">
         <option name="dns_domain" type="string">Name of the DNS domain</option>
      </optgroup>
      <optgroup name="update_dns_domain_optional_options" mandatory="False">
         <option name="comments" type="string">Comments</option>
         <option name="restricted" type="boolean">Restrict direct DNS manipulation commands</option>
      </optgroup>
      <transport method="post" path="dns_domain/%(dns_domain)s" />
   </command>

   <command name="dump_dns">
      Dump DNS information.
      <p/>
      <optgroup name="dump_dns_optional" mandatory="False" fields="any">
         <option name="dns_domain" type="string">Name of the DNS domain</option>
         <option name="dns_environment" type="string">The name of the environment (defaults to 'internal')</option>
      </optgroup>
      <transport method="get" path="dump_dns" />
   </command>

   <command name="add_metacluster">
      Add a new metacluster.
      <optgroup name="add_metacluster_req" mandatory="True" fields="all">
         <option name="metacluster" type="string">Name of the new metacluster</option>
      </optgroup>
      <optgroup name="add_metacluster_options" mandatory="False">
         <option name="max_members" type="int">Comments</option>
         <option name="max_shares" type="int">Comments</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="metacluster/%(metacluster)s" />
   </command>

   <command name="show_metacluster">
      Show details for a metacluster.
      <optgroup name="show_metacluster_req" mandatory="True" fields="any">
         <option name="metacluster" type="string" conflicts="all">Name of the metacluster</option>
         <option name="all" type="flag" conflicts="metacluster">Show all</option>
      </optgroup>
      <transport trigger="all" method="get" path="metacluster" />
      <transport trigger="metacluster" method="get" path="metacluster/%(metacluster)s" />
   </command>

   <command name="update_metacluster">
      Update a metacluster.
      <optgroup name="update_metacluster_req" mandatory="True" fields="all">
         <option name="metacluster" type="string">Name of the metacluster</option>
      </optgroup>
      <optgroup name="update_metacluster_options" mandatory="False">
         <option name="max_members" type="int">Maximum number of clusters that can be members of this metacluster</option>
         <option name="max_shares" type="int">Maximum number of shares that virtual machines may use</option>
         <option name="comments" type="string">Comments</option>
         <option name="high_availability" type="boolean">Turn on high availaibility mode</option>
      </optgroup>
      <transport method="post" path="metacluster/%(metacluster)s" />
   </command>

   <command name="del_metacluster">
      Delete the metacluster.
      <optgroup name="del_metacluster_req" mandatory="True" fields="all">
         <option name="metacluster" type="string">Name of the metacluster</option>
      </optgroup>
      <transport method="delete" path="metacluster/%(metacluster)s" />
   </command>

   <command name="show_cluster">
      Show details for a cluster.
      <optgroup name="show_cluster_req" mandatory="True" fields="any">
         <option name="cluster" type="string" conflicts="all">Name of the cluster</option>
         <option name="all" type="flag" conflicts="cluster">Show all clusters</option>
      </optgroup>
      <transport trigger="cluster" method="get" path="cluster/%(cluster)s" />
      <transport trigger="all" method="get" path="cluster/" />
   </command>

   <command name="add_esx_cluster">
      Add a new ESX cluster.
      <p/>
      Each ESX cluster must belong to a metacluster.
      <p/>
      Two constraints must be defined.  The cluster has a location constraint.
      All cluster vmhosts must be within the same location.  All of the
      cluster's vmhosts must also have the same personality.
      <p/>
      The max_members option can be set to define the maximum number of
      vmhosts that can be members of the cluster.
      <p/>
      The "down hosts threshold" is the number of hosts needed as "effective
      spares" per hardware model and cluster layout.  This value is used
      for cluster montioring alerts.
      <p/>
      The vm_to_host_ratio constrains the number of virtual machines
      allowed on the cluster based on the number of vmhosts.  This
      ratio is checked when adding virtual machines to a cluster or
      removing vmhosts from a cluster.  The check assumes
      down_hosts_threshold less hosts than are currently bound to the
      cluster.
      <optgroup name="add_esx_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the new esx_cluster</option>
         <option name="metacluster" type="string">Name of the metacluster containing this cluster</option>
         <option name="down_hosts_threshold" type="string">Number of vmhosts that can be down before monitoring alarms trigger</option>
         <optgroup name="add_cluster_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="archetype" type="string">Archetype name</option>
         <option name="personality" type="string">Personality name</option>
         <optgroup name="branch_opts" fields="any">
            <option name="domain" type="string" conflicts="sandbox">Name of template domain</option>
            <option name="sandbox" type="string" conflicts="domain">Name of the sandbox (given as 'author/branch')</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_esx_cluster_options" mandatory="False">
         <option name="maint_threshold" type="string">Down hosts threshold for maintenance windows</option>
         <option name="max_members" type="int">Comments</option>
         <option name="vm_to_host_ratio" type="string">Ratio of virtual machines to ESX servers</option>
         <option name="switch" type="string">switch in use by the cluster</option>
         <option name="buildstatus" type="string">Build status of the cluster (defaults to 'build')</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="cluster/esx/%(cluster)s" />
   </command>

   <command name="show_esx_cluster">
      Show details for an ESX cluster. DEPRECATED
      <optgroup name="show_cluster_req" mandatory="True" fields="any">
         <option name="cluster" type="string" conflicts="all">Name of the cluster</option>
         <option name="all" type="flag" conflicts="cluster">Show all clusters</option>
      </optgroup>
      <transport trigger="cluster" method="get" path="cluster/esx/%(cluster)s" />
      <transport trigger="all" method="get" path="cluster/esx" />
   </command>

   <command name="update_esx_cluster">
      Update an ESX cluster.
      <p/>
      The cluster vmhost members are constrained to be in the same location
      and have the same personality.  An attempt to update any constraint
      that cannot be satisfied will fail.
      <optgroup name="update_esx_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the ESX cluster</option>
      </optgroup>
      <optgroup name="update_esx_cluster_options" mandatory="False">
         <option name="personality" type="string">Personality Name</option>
         <option name="down_hosts_threshold" type="string">Down hosts threshold</option>
         <option name="maint_threshold" type="string">Down hosts threshold for maintenance windows</option>
         <option name="max_members" type="int">Max allowed vmhost members</option>
         <option name="vm_to_host_ratio" type="string">Ratio of virtual machines to ESX servers</option>
         <option name="switch" type="string" conflicts="tor_switch">Set the switch in use by the cluster.  An empty string removes the setting.</option>
         <option name="tor_switch" type="string" conflicts="switch">[DEPRECATED] Set the switch in use by the cluster.  An empty string removes the setting.</option>
         <option name="fix_location" type="flag">Set the location based on cluster membership.</option>
         <option name="comments" type="string">Comments</option>
         <option name="memory_capacity" type="int" conflicts="clear_overrides">Override the computed memory capacity</option>
         <option name="clear_overrides" type="flag" conflicts="override_memory_capacity">Clear capacity overrides</option>
         <optgroup name="update_cluster_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="cluster/esx/%(cluster)s" />
   </command>

   <command name="del_esx_cluster">
      Delete the ESX cluster.
      <optgroup name="del_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the cluster</option>
      </optgroup>
      <transport method="delete" path="cluster/esx/%(cluster)s" />
   </command>

   <command name="add_cluster">
      Add a new cluster.
      <optgroup name="add_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the new cluster</option>
         <option name="down_hosts_threshold" type="string">Number of hosts that can be down before monitoring alarms trigger</option>
         <optgroup name="add_cluster_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="archetype" type="string">Archetype name</option>
         <option name="personality" type="string">Personality name</option>
         <optgroup name="branch_opts" fields="any">
            <option name="domain" type="string" conflicts="sandbox">Name of template domain</option>
            <option name="sandbox" type="string" conflicts="domain">Name of the sandbox (given as 'author/branch')</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_cluster_options" mandatory="False">
         <option name="metacluster" type="string">Name of the metacluster containing this cluster</option>
         <option name="maint_threshold" type="string">Down hosts threshold for maintenance windows</option>
         <option name="max_members" type="int">Comments</option>
         <option name="vm_to_host_ratio" type="string">Ratio of virtual machines to ESX servers</option>
         <option name="switch" type="string">switch in use by the cluster</option>
         <option name="buildstatus" type="string">Build status of the cluster (defaults to 'build')</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="cluster/%(cluster)s" />
   </command>

   <command name="update_cluster">
      Update a cluster.
      <optgroup name="update_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the cluster</option>
      </optgroup>
      <optgroup name="update_cluster_options" mandatory="False">
         <option name="personality" type="string">Personality Name</option>
         <option name="down_hosts_threshold" type="string">Down hosts threshold</option>
         <option name="maint_threshold" type="string">Down hosts threshold for maintenance windows</option>
         <option name="max_members" type="int">Max allowed host members</option>
         <option name="vm_to_host_ratio" type="string">Ratio of virtual machines to ESX servers</option>
         <option name="tor_switch" type="string" conflicts="switch">DEPRECATED Set the switch in use by the cluster.  An empty string removes the setting.</option>
         <option name="switch" type="string" conflicts="tor_switch">Set the switch in use by the cluster.  An empty string removes the setting.</option>
         <option name="fix_location" type="flag">Set the location based on cluster membership.</option>
         <option name="comments" type="string">Comments</option>
         <option name="memory_capacity" type="int" conflicts="clear_overrides">Override the computed memory capacity</option>
         <option name="clear_overrides" type="flag" conflicts="override_memory_capacity">Clear capacity overrides</option>
         <optgroup name="update_cluster_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="cluster/%(cluster)s" />
   </command>

   <command name="del_cluster">
      Delete the cluster.
      <optgroup name="del_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the cluster</option>
      </optgroup>
      <transport method="delete" path="cluster/%(cluster)s" />
   </command>

   <command name="add_allowed_personality">
      add a personality to the allowed list of a cluster
      <optgroup name="add_allow_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the cluster</option>
         <option name="archetype" type="string">Name of the archetype</option>
         <option name="personality" type="string">Name of the personality</option>
      </optgroup>
      <transport method="put" path="cluster/%(cluster)s/allowed/%(archetype)s/%(personality)s" />
   </command>

   <command name="del_allowed_personality">
      delete a personality from the allowed list of a cluster
      <optgroup name="del_allow_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the cluster</option>
         <option name="archetype" type="string">Name of the archetype</option>
         <option name="personality" type="string">Name of the personality</option>
      </optgroup>
      <transport method="delete" path="cluster/%(cluster)s/allowed/%(archetype)s/%(personality)s" />
   </command>

   <command name="rebind_metacluster">
      Change metacluster bindings.
      <p/>
      This will move the cluster into the named metacluster.
      <optgroup name="rebind_client_opts" mandatory="True" fields="all">
         <option name="metacluster" type="string">MetaCluster name</option>
         <option name="cluster" type="string">Cluster name</option>
      </optgroup>
      <transport method="post" path="metacluster/%(metacluster)s/cluster/%(cluster)s/rebind" />
   </command>

   <command name="bind_esx_cluster">
      Bind a service instance to the named cluster.
      <p/>
      If binding a service instance for a service that is already bound to
      a different instance this command will fail.
      <optgroup name="bind_esx_cluster_opts" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name</option>
         <optgroup name="bind_esx_cluster_object" mandatory="True" fields="any">
            <optgroup name="bind_esx_cluster_service" mandatory="False" fields="all">
               <option name="service" type="string">Service name</option>
               <option name="instance" type="string">Service Instance</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <transport method="put" trigger="service" path="cluster/esx/%(cluster)s/service/%(service)s/%(instance)s" />
   </command>

   <command name="rebind_esx_cluster">
      Bind a service instance to the named cluster.
      <p/>
      If binding a service instance for a service that is already bound to
      a different instance the old binding will be removed.
      <optgroup name="rebind_esx_cluster_opts" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name</option>
	 <optgroup name="rebind_esx_cluster_object" mandatory="True" fields="any">
	    <optgroup name="rebind_esx_cluster_service" fields="all">
               <option name="service" type="string">Service name</option>
               <option name="instance" type="string">Service Instance</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <transport method="post" trigger="service" path="cluster/esx/%(cluster)s/service/%(service)s/%(instance)s" />
   </command>

   <command name="unbind_esx_cluster">
      Remove the binding of the service instance from the named cluster.

      <optgroup name="unbind_esx_cluster_opts" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name</option>
	    <optgroup name="unbind_esx_cluster_service" mandatory="False" fields="all">
               <option name="service" type="string">Service name</option>
               <option name="instance" type="string">Service Instance</option>
         </optgroup>
      </optgroup>
      <transport method="delete" trigger="service" path="cluster/esx/%(cluster)s/service/%(service)s/%(instance)s" />
   </command>

   <command name="cluster">
      Cluster a host.
      <p/>
      This adds the given host into the given cluster.  This is a potentially
      destructive operation as any previous cluster membership of the host
      will be revoked.
      <p/>
      If the personality is specified then the named personality will be
      assigned to the host on entry to the cluster.
      <optgroup name="cluster_mandatory" mandatory="True" fields="all">
         <option name="hostname" type="string">Server name</option>
         <option name="cluster" type="string">Cluster name</option>
      </optgroup>
      <optgroup name="cluster_opts">
         <option name="personality" type="string">New personality of host</option>
      </optgroup>
      <transport method="put" path="cluster/%(cluster)s/host/%(hostname)s" />
   </command>

   <command name="uncluster">
      Remove the host from the named cluster. If the personality is specified
      then the new personality is applied to the host on exit from the cluster.
      <optgroup name="uncluster_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Server name</option>
         <option name="cluster" type="string">Cluster name</option>
      </optgroup>
      <optgroup name="cluster_opts">
         <option name="personality" type="string">New personality of host</option>
      </optgroup>
      <transport method="delete" path="cluster/%(cluster)s/host/%(hostname)s" />
   </command>

   <command name="add_cluster_aligned_service">
      Mark a service as aligned for a cluster type.  All the members within a
      cluster will be required to use the same service instance for the
      service.  Different clusters can still have different service
      instances for the service.
      <optgroup name="add_aligned_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="cluster_type" type="string" mandatory="True">type of cluster</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="service/%(service)s/aligned_for/cluster_type/%(cluster_type)s" />
   </command>

   <command name="show_cluster_type">
      Show information about a cluster_type such as esx, including aligned
      services.
      <optgroup name="show_cluster_type_opts" mandatory="True" fields="any">
         <option name="cluster_type" type="string">cluster_type name</option>
         <option name="all" type="flag" conflicts="cluster_type">Select all cluster types</option>
      </optgroup>
      <transport trigger="cluster_type" method="get" path="cluster_type/%(cluster_type)s" />
      <transport trigger="all" method="get" path="cluster_type" />
   </command>

   <command name="del_cluster_aligned_service">
      Delete a service from the list of aligned services for the
      cluster_type.  Cluster members which are already bound to a
      service because it used to be aligned will be unmodified. If
      you wish to unbind those clients, they must be reconfigured.
      <optgroup name="del_aligned_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="cluster_type" type="string" mandatory="True">type of cluster</option>
      </optgroup>
      <transport method="delete" path="service/%(service)s/aligned_for/cluster_type/%(cluster_type)s" />
   </command>

   <command name="add_dynamic_range">
      Add the allocated range of dynamic hosts.  The start and end
      IP addresses are inclusive.  The IPs must be on the same network.
      If there are any allocated systems already in the range the command
      will fail.
      <p/>
      For every IP address in the range a DNS entry will be generated of
      the form: prefix-X-X-X-X.subdomain where the X's are the components
      of the IP address.  The prefix defaults to the string 'dynamic'.
      <optgroup name="add_dynamic_range_opts" mandatory="True" fields="all">
         <option name="dns_domain" type="string" mandatory="True">DNS domain to use for the generated names</option>
         <optgroup name="add_dynamic_range_specs" mandatory="True" fields="any">
            <option name="fillnetwork" type="string" conflicts="startip endip">Allocate dynamic IPs for all available addresses in the network</option>
            <optgroup name="add_dynamic_range_startend" fields="all">
               <option name="startip" type="ipv4" conflicts="fillnetwork">First IP address in the range to add</option>
               <option name="endip" type="ipv4" conflicts="fillnetwork">Last IP address in the range to add</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <optgroup name="add_dynamic_range_opts" mandatory="False" fields="any">
         <option name="prefix" type="string">Prefix to use for generated names, defaults to 'dynamic'</option>
      </optgroup>
      <transport method="put" path="dynamic_range/%(startip)s/%(endip)s" />
      <transport trigger="fillnetwork" method="post" path="dynamic_range/fill/%(fillnetwork)s" />
   </command>

   <command name="del_dynamic_range">
      Delete the allocated range of dynamic hosts.  The start and end
      IP addresses are inclusive.  The IPs must be on the same network.
      If there are any allocated systems in the range that are not
      dynamic the command will fail.
      <optgroup name="del_dynamic_range_opts" mandatory="True" fields="any">
         <option name="clearnetwork" type="string" conflicts="startip endip">Remove dynamic entries from the network</option>
         <optgroup name="del_dynamic_range_startend" fields="all">
            <option name="startip" type="ipv4" conflicts="clearnetwork">First IP address in the range to delete</option>
            <option name="endip" type="ipv4" conflicts="clearnetwork">Last IP address in the range to delete</option>
         </optgroup>
      </optgroup>
      <transport method="delete" path="dynamic_range/%(startip)s/%(endip)s" />
      <transport trigger="clearnetwork" method="post" path="dynamic_range/clear/%(clearnetwork)s" />
   </command>

   <command name="show_dynamic_range">
      Show a range reserved for dynamic DHCP.
      <optgroup name="show_dynamic_range_opts" mandatory="True" fields="any">
         <option name="ip" type="ipv4" conflicts="fqdn">Any IP address inside the range</option>
	 <option name="fqdn" type="string" conflicts="ip">Any FQDN inside the range</option>
      </optgroup>
      <optgroup name="show_dynamic_range_optional" mandatory="False" fields="any">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="get" path="dynamic_range"/>
   </command>

   <command name="add_address">
      Add DNS addresses to the database.
      <p/>
      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      <p/>
      Three algorithms are available for deriving the IP address:
      lowest:         Use the lowest available IP in the subnet.
      highest:        Use the highest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_address_mandatory" mandatory="True" fields="all">
         <option name="fqdn" type="string">A fully qualified domain name</option>
         <optgroup name="add_address_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="ipv4" conflicts="ipfromip ipfromsystem">IP address</option>
            <option name="ipfromip" type="ipv4" conflicts="ip ipfromsystem">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip">choose IP address in subnet of system</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_address_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="address_default/%(fqdn)s" />
      <transport method="post" trigger="dns_environment" path="address/%(dns_environment)s/%(fqdn)s" />
   </command>

   <command name="del_address">
      Delete an address record from the database.
      <optgroup name="del_address_mandatory" mandatory="True" fields="any">
         <option name="fqdn" type="string">The fully qualified domain name</option>
         <option name="ip" type="ipv4">An IP Address</option>
      </optgroup>
      <optgroup name="del_address_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="delete" path="address_default" />
      <transport method="delete" trigger="dns_environment" path="address/%(dns_environment)s" />
   </command>

   <command name="show_address">
      Show an address in the DNS.
      <optgroup name="show_address_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">The fully qualified domain name</option>
      </optgroup>
      <optgroup name="show_address_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="get" path="address_default/%(fqdn)s" />
      <transport method="get" trigger="dns_environment" path="address/%(dns_environment)s/%(fqdn)s" />
   </command>

   <command name="show_ns_record">
      Display NS Records
      <optgroup name="show_ns_record_opts" mandatory="True" fields="any">
           <optgroup name="show_one_ns_record" mandatory="False" fields="all">
               <option name="dns_domain" type="string">The dns domain name</option>
               <option name="fqdn" type="string">The fully qualified domain name of the server</option>
           </optgroup>
           <option name="all" type="flag" conflicts="fqdn dns_domain">Select all NS Records</option>
      </optgroup>
      <transport method="get" path="ns_record/%(dns_domain)s/%(fqdn)s"/>
      <transport trigger="all" method="get" path="ns_record"/>
   </command>

   <command name="add_ns_record">
      Add an NS Record (Name Server) to a Dns Domain/Environment
      <optgroup name="add_ns_record_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">The fully qualified domain name of the name server</option>
         <option name="dns_domain" type="string">The dns domain to add the record to</option>
      </optgroup>
      <optgroup name="add_ns_record_optional" mandatory="False">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="ns_record/%(dns_domain)s/%(fqdn)s" />
   </command>

   <command name="del_ns_record">
      Delete an NS Record (Name Server) to a Dns Domain/Environment
      <optgroup name="del_ns_record_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">The fully qualified domain name of the name server to delete</option>
         <option name="dns_domain" type="string">The dns domain to delete the record from</option>
      </optgroup>
      <transport method="delete" path="ns_record/%(dns_domain)s/%(fqdn)s" />
   </command>

   <command name="add_alias">
      Add DNS aliases to the database.
      <optgroup name="add_alias_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">A fully qualified domain name</option>
         <option name="target" type="string">The target of an alias (CNAME)</option>
      </optgroup>
      <optgroup name="add_alias_optional" mandatory="False">
         <option name="comments" type="string">Comments</option>
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="put" path="alias/%(fqdn)s" />
   </command>

   <command name="del_alias">
      Delete a DNS alias from the database.
      <optgroup name="del_alias_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">The fully qualified domain name</option>
      </optgroup>
      <optgroup name="del_alias_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="delete" path="alias/%(fqdn)s" />
   </command>

   <command name="show_alias">
      Show an alias in the DNS.
      <optgroup name="show_alias_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">The fully qualified domain name</option>
      </optgroup>
      <optgroup name="show_alias_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the alias is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="get" path="alias/%(fqdn)s" />
   </command>

   <command name="update_alias">
      Update a DNS alias.
      <optgroup name="update_alias_opts" mandatory="True" fields="all">
         <option name="fqdn" type="string">The fully qualified domain name</option>
      </optgroup>
      <optgroup name="update_alias_optional" mandatory="False">
         <option name="target" type="string">The new target of the alias</option>
         <option name="comments" type="string">Comments</option>
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="post" path="alias/%(fqdn)s" />
   </command>

   <command name="add_srv_record">
      Add a DNS SRV record to the database.
      <optgroup name="add_srv_record_opts" mandatory="True" fields="all">
         <option name="service" type="string">The name of the service</option>
         <option name="protocol" type="string">The name of the protocol (tcp, udp)</option>
         <option name="dns_domain" type="string">The name of the DNS domain</option>
         <option name="priority" type="int">The priority of the record</option>
         <option name="weight" type="int">The weight of the record</option>
         <option name="target" type="string">The target of the SRV record</option>
	 <option name="port" type="int">The port on the target where the service listens</option>
      </optgroup>
      <optgroup name="add_srv_record_optional" mandatory="False">
         <option name="comments" type="string">Comments</option>
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="put" path="srv_record/%(dns_domain)s/%(protocol)s/%(service)s" />
   </command>

   <command name="del_srv_record">
      Delete a DNS SRV from the database.
      <p/>
      If --target is not specified, then all matching SRV records are deleted.
      <optgroup name="del_srv_record_opts" mandatory="True" fields="all">
         <option name="service" type="string">The name of the service</option>
         <option name="protocol" type="string">The name of the protocol (tcp, udp)</option>
         <option name="dns_domain" type="string">The name of the DNS domain</option>
      </optgroup>
      <optgroup name="del_srv_record_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
         <option name="target" type="string">The target of the SRV record</option>
      </optgroup>
      <transport method="delete" path="srv_record/%(dns_domain)s/%(protocol)s/%(service)s" />
   </command>

   <command name="show_srv_record">
      Show DNS SRV records.
      <optgroup name="show_srv_record_opts" mandatory="True" fields="all">
         <option name="service" type="string">The name of the service</option>
         <option name="protocol" type="string">The name of the protocol (tcp, udp)</option>
         <option name="dns_domain" type="string">The name of the DNS domain</option>
      </optgroup>
      <optgroup name="show_srv_record_optional" mandatory="False">
         <option name="dns_environment" type="string">The name of the environment the srv_record is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="get" path="srv_record/%(dns_domain)s/%(protocol)s/%(service)s" />
   </command>

   <command name="update_srv_record">
      Update a DNS SRV record.
      <optgroup name="update_srv_record_opts" mandatory="True" fields="all">
         <option name="service" type="string">The name of the service</option>
         <option name="protocol" type="string">The name of the protocol (tcp, udp)</option>
         <option name="dns_domain" type="string">The name of the DNS domain</option>
         <option name="target" type="string">The target of the SRV record</option>
      </optgroup>
      <optgroup name="update_srv_record_optional" mandatory="False">
         <option name="priority" type="int">The new priority of the record</option>
         <option name="weight" type="int">The new weight of the record</option>
         <option name="port" type="int">The new port on the target where the service listens</option>
         <option name="comments" type="string">Comments</option>
         <option name="dns_environment" type="string">The name of the environment the address is in (defaults to 'internal')</option>
      </optgroup>
      <transport method="post" path="srv_record/%(dns_domain)s/%(protocol)s/%(service)s" />
   </command>

   <command name='search_dns'>
      Search DNS records in the database.
      <p/>
      If you specify multiple search criteria then only records matching all of them
      will be returned.
      <p/>
      For record_type you can use either the standard DNS RR type names (A, CNAME<!--, SRV -->)
      or the internal names.
      <optgroup name="search_dns_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string">A fully qualified domain name</option>
         <option name="shortname" type="string">The short name</option>
         <option name="record_type" type="string">The type of the DNS record</option>
         <option name="ip" type="ipv4">An IP Address (for A records)</option>
         <option name="network" type="string">Network name or address (for A records)</option>
         <option name="target" type="string">The target of an alias or service (for CNAME records)</option>
         <option name="target_domain">The DNS domain of the target of an alias or service</option>
         <!-- <option name="service" type="string">The symbolic name of the service (for SRV records)</option> -->
         <option name="dns_domain" type="string">Name of the DNS domain the record lives in</option>
         <option name="primary_name" type="boolean">The DNS record is used as a primary name</option>
         <option name="used" type="boolean" reverse="unused">The IP address is in use</option>
      </optgroup>
      <optgroup name="search_dns_optional" mandatory="False" fields="any">
         <option name="dns_environment" type="string" conflicts="network_environment">The name of an environment the address is in (default: internal)</option>
         <option name="network_environment" type="string" conflicts="dns_environment"> The network environment for A records (default: internal)</option>
         <option name="fullinfo" type="flag">Show full information for the matching records</option>
      </optgroup>
      <transport method="get" path="find/dns_record"/>
   </command>

   <command name="map_dns_domain">
      Map a DNS domain to the given location.
      <optgroup name="map_dns_domain_opts" mandatory="True" fields="all">
         <option name="dns_domain" type="string">The fully qualified domain name</option>
         <optgroup name="map_dns_domain_loc_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <optgroup name="map_dns_domain_opt" mandatory="False">
         <option name="position" type="int">Position in the list</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="dns_map/%(dns_domain)s/command/map" />
   </command>

   <command name="unmap_dns_domain">
      Unmap a DNS domain from the given location.
      <optgroup name="unmap_dns_domain_opts" mandatory="True" fields="all">
         <option name="dns_domain" type="string">The fully qualified domain name</option>
         <optgroup name="unmap_dns_domain_loc_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="dns_map/%(dns_domain)s/command/unmap" />
   </command>

   <command name="search_dns_domain_map">
      Search DNS domain maps.
      <p/>
      If a location is specified and the --include_parents flag is used, then any
      mappings of parent locations are also included. This allows testing what would
      be included in the DNS search path if a machine was placed at the given location.
      <optgroup name="search_dns_domain_opts" mandatory="True" fields="any">
         <option name="dns_domain" type="string">The fully qualified domain name</option>
         <option name="organization" type="string">Organization</option>
         <option name="hub" type="string">Hub</option>
         <option name="continent" type="string">Continent</option>
         <option name="country" type="string">Country</option>
         <option name="campus" type="string">Campus</option>
         <option name="city" type="string">City</option>
         <option name="building" type="string">Building</option>
         <option name="room" type="string">Room</option>
         <option name="rack" type="string">Rack</option>
         <option name="desk" type="string">Desk</option>
      </optgroup>
      <optgroup name="search_dns_domain_optional" mandatory="False" fields="any">
         <option name="include_parents" type="flag">Include maps of parent locations</option>
      </optgroup>
      <transport method="get" path="find/dns_map" />
   </command>

   <command name="search_audit">
      Search for activity in the transaction logs.
      <p/>
      Defaults:
      <p/>
      The default is only to search for commands that create, update or
      delete data.  There are some special values for the command option to
      provide customization to this behavior:
      <p/>"rw": includes read only commands except 'cat' and "show_active_*"
      <p/>"all": includes ALL commands including the above
      <p/>Date specifications: MM-DD-YY (midnight UTC),
      or "MM-DD-YY HH:MM:SS+OOOO" (quotes needed).
      <p/>
      Some more complex formats are capable, details can be found in
      the "parser" section of http://niemeyer.net/python-dateutil
      <p/>The limit option defaults to 5000 and has a maximum of 20000
      in order to enhance performance and stability.
      <optgroup name="search_audit_opts" mandatory="True" fields="any">
         <option name="keyword" type="string">The value of any argument supplied to a command</option>
         <option name="username" type="string">The user name who executed the command</option>
         <option name="command" type="string">The name of the command (see "Defaults")</option>
         <option name="before" type="string">Search for transactions started before a specific date/time</option>
         <option name="after" type="string">Search for transactions started after a specific date/time</option>
         <option name="return_code" type="int">Search by an HTTP response code (200-505)</option>
         <option name="limit" type="int">Limit the number of rows returned. (Default 5000/Max 20000)</option>
         <option name="reverse_order" type="boolean">Output records in
         reverse chronological order. Also causes the --limit
         parameter to find the oldest records and not the newest.
         </option>
      </optgroup>
      <transport method="get" path="find/audit" />
   </command>

   <command name="show_reboot_schedule">
      Show reboot_schedule based on filtering for host/cluster association
      <optgroup name="show_resource_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="all" type="flag">list all schedules</option>
      </optgroup>
      <transport method="get" path="resource/reboot_schedule/reboot_schedule" />
   </command>

   <command name="add_reboot_schedule">
      Add a new reboot schedule to a host or cluster.
      <p/>
      WW must match personality maintenance window. Preferred time (if
      specified) must be in WW. Time is always the host region's local
      time.
      <p/>
      For schedule to take affect the server must be bound to reboot
      service instance 'scheduled'. A warning will be printed if not.
      <optgroup name="add_res_opts" mandatory="True" fields="all">
         <option name="week" type="string" default="all">Comma separated week (1-5 or all)</option>
         <option name="day" type="string" default="Sun">Week day (Sun,Mon...Sat) maching maintenance WW</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="time" type="string">Preferred time (omit for anytime within WW)</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname to apply resource</option>
         <option name="cluster" type="string">Cluster to apply resource</option>
      </optgroup>
      <transport method="put" path="resource/reboot_schedule" />
   </command>

   <command name="del_reboot_schedule">
      Delete the reboot schedule resource.
      <p/>
      For a host bound to reboot service instance 'scheduled' a warning
      will printed at compile time if no schedule exists. The host will
      not reboot.
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname to apply resource</option>
         <option name="cluster" type="string">Cluster to apply resource</option>
      </optgroup>
      <transport method="delete" path="resource/reboot_schedule" />
   </command>

   <command name="show_reboot_intervention">
      Show reboot_intervention based on filtering for host/cluster association
      <optgroup name="show_resource_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="all" type="flag">list all interventions</option>
      </optgroup>
      <transport method="get" path="resource/reboot_intervention" />
   </command>

   <command name="add_reboot_intervention">
      Add a new reboot intervention resource.

      <p/> The intervention will apply after host compilation and NCM
      update and so should be done in plenty of time before the
      scheduled reboot is to take place.

      <p/> This intervention treats date as the whole day inclusive to
      expiry. Time of the intervention is ignored.

      <p/> Only a single reboot intervention can be in place at once.

      <optgroup name="add_riv_opts" mandatory="True" fields="all">
         <option name="expiry" type="string">when to expire this intervention</option>
         <option name="justification" type="string">the reason for the intervention</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
         <option name="start_time" type="string">when to start this intervention (default=now)</option>
      </optgroup>
      <optgroup name="optional_binding" fields="any">
         <option name="hostname" type="string">Host</option>
         <option name="cluster" type="string">Cluster</option>
      </optgroup>
      <transport method="post" path="resource/reboot_intervention" />
   </command>

   <command name="del_reboot_intervention">
      Delete the reboot intervention resource.

      <p/> The intervention will be removed after host compilation and NCM
      update.
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname to apply resource</option>
         <option name="cluster" type="string">Cluster to apply resource</option>
      </optgroup>
      <transport method="delete" path="resource/reboot_intervention" />
   </command>

   <command name="add_filesystem">
      Add a new filesystem resource.
      <optgroup name="add_fs_opts" mandatory="True" fields="all">
         <option name="filesystem" type="string">name</option>
         <option name="type" type="string">type</option>
         <option name="mountpoint" type="string">mountpoint</option>
         <option name="blockdevice" type="string">blockdevice</option>
         <option name="bootmount" type="boolean">immediately mount on boot</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="dumpfreq" type="int" default='0'>dump frequency</option>
         <option name="fsckpass" type="int" default='2'>fsck passno</option>
         <option name="options" type="string">mountoptions</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname to apply resource</option>
         <option name="resourcegroup" type="string">Resourcegroup to apply resource</option>
         <option name="cluster" type="string">Cluster to apply resource</option>
      </optgroup>
      <transport method="put" path="resource/filesystem/%(filesystem)s" />
   </command>

   <command name="del_filesystem">
      Delete a filesystem resource.
      <optgroup name="del_fs_opts" mandatory="True" fields="all">
         <option name="filesystem" type="string">name</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname of resource</option>
         <option name="resourcegroup" type="string">Resourcegroup to apply resource</option>
         <option name="cluster" type="string">Cluster of resource</option>
      </optgroup>
      <transport method="delete" path="resource/filesystem/%(filesystem)s" />
   </command>

   <command name="show_filesystem">
      Show filesystems based on filtering for host/cluster association
      <optgroup name="show_resource_opts" mandatory="True" fields="any">
         <option name="resourcegroup" type="string">resourcegroup name</option>
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="filesystem" type="string">filesystem name</option>
         <option name="all" type="flag">list all hardware</option>
      </optgroup>
      <transport method="get" trigger="filesystem" path="resource/filesystem/%(filesystem)s" />
      <transport method="get" path="find/resource/filesystem" />
   </command>

   <command name="add_application">
      Add a new application resource.
      <optgroup name="add_app_opts" mandatory="True" fields="all">
         <option name="application" type="string">Name of applicaiton</option>
         <option name="eonid" type="int">EON identity</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="resourcegroup" type="string">Resourcegroup to apply resource</option>
         <option name="hostname" type="string">Hostname to apply resource</option>
         <option name="cluster" type="string">Cluster to apply resource</option>
      </optgroup>
      <transport method="put" path="resource/application/%(application)s" />
   </command>

   <command name="del_application">
      Delete an application resource.
      <optgroup name="del_app_opts" mandatory="True" fields="all">
         <option name="application" type="string">name</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="resourcegroup" type="string">Resourcegroup to apply resource</option>
         <option name="hostname" type="string">Hostname of resource</option>
         <option name="cluster" type="string">Cluster of resource</option>
      </optgroup>
      <transport method="delete" path="resource/application/%(application)s" />
   </command>

   <command name="show_application">
      Show applications based on filtering for host/cluster association
      <optgroup name="show_resource_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="resourcegroup" type="string">resourcegroup</option>
         <option name="application" type="string">application name</option>
         <option name="eonid" type="int">EON id</option>
         <option name="all" type="flag">list all hardware</option>
      </optgroup>
      <transport method="get" trigger="application" path="resource/application/%(application)s" />
      <transport method="get" path="find/resource/application" />
   </command>

   <command name="add_hostlink">
      Add a new hostlink resource.
      <optgroup name="add_app_opts" mandatory="True" fields="all">
         <option name="hostlink" type="string">Name of hostlink</option>
         <option name="target" type="string">Target path of link</option>
         <option name="owner" type="string">Username to be owner of the
         target directory</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="group" type="string">Group owner of the target
         directory</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="resourcegroup" type="string">Resourcegroup to apply resource</option>
         <option name="hostname" type="string">Hostname to apply resource</option>
         <option name="cluster" type="string">Cluster to apply resource</option>
      </optgroup>
      <transport method="put" path="resource/hostlink/%(hostlink)s" />
   </command>

   <command name="del_hostlink">
      Delete an hostlink resource.
      <optgroup name="del_app_opts" mandatory="True" fields="all">
         <option name="hostlink" type="string">name</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="resourcegroup" type="string">Resourcegroup to apply resource</option>
         <option name="hostname" type="string">Hostname of resource</option>
         <option name="cluster" type="string">Cluster of resource</option>
      </optgroup>
      <transport method="delete" path="resource/hostlink/%(hostlink)s" />
   </command>

   <command name="show_hostlink">
      Show a hostlink resource.
      <optgroup name="show_resource_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="resourcegroup" type="string">resourcegroup</option>
         <option name="hostlink" type="string">hostlink name</option>
         <option name="all" type="flag">list all hostlinks</option>
      </optgroup>
      <transport method="get" trigger="hostlink" path="resource/hostlink/%(hostlink)s" />
      <transport method="get" path="find/resource/hostlink" />
   </command>


   <command name="add_intervention">
      Add a new intervention resource.
      <optgroup name="add_iv_opts" mandatory="True" fields="all">
         <option name="expiry" type="string">when to expire this intervention</option>
         <option name="intervention" type="string">the name of the intervention</option>
         <option name="justification" type="string">the reason for the intervention</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
         <option name="allowusers" type="string">Additional users allowed access</option>
         <option name="allowgroups" type="string">Additional groups allowed access</option>
         <option name="disabled_actions" type="string">Disabled actions</option>
         <option name="start_time" type="string">when to start this intervention (default=now)</option>
      </optgroup>
      <optgroup name="optional_binding" fields="any">
         <option name="hostname" type="string">Host</option>
         <option name="cluster" type="string">Cluster</option>
      </optgroup>
      <transport method="post" path="resource/intervention/%(intervention)s" />
   </command>

   <command name="show_intervention">
      Display the attributes of an existing intervention resource.
      <optgroup name="add_iv_opts" mandatory="True" fields="any">
         <option name="intervention" type="string">the name of the intervention</option>
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="resourcegroup" type="string">resource group</option>
         <option name="all" type="flag">list all hardware</option>
      </optgroup>
      <transport method="get" trigger="intervention" path="resource/intervention/%(intervention)s" />
      <transport method="get" path="find/resource/intervention" />
   </command>

   <command name="del_intervention">
      Delete an intervention resource.
      <optgroup name="del_iv_opts" mandatory="True" fields="all">
         <option name="intervention" type="string">name</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname of resource</option>
         <option name="cluster" type="string">Cluster of resource</option>
      </optgroup>
      <transport method="delete" path="resource/intervention/%(intervention)s" />
   </command>

   <command name="add_grn">
      Add a new GRN.
      <optgroup name="add_grn_required" mandatory="true" fields="all">
         <option name="grn" type="string">GRN as string</option>
         <option name="eon_id" type="int">Numeric EON ID</option>
      </optgroup>
      <optgroup name="add_grn_optional" mandatory="false" fields="any">
         <option name="disabled" type="flag">GRN is disabled and cannot be added to new systems</option>
      </optgroup>

      <transport method="put" path="grn/%(eon_id)s/%(grn)s" />
   </command>

   <command name="del_grn">
      Delete a GRN.
      <optgroup name="del_grn_required" mandatory="true" fields="any">
         <option name="grn" type="string" conflicts="eon_id">GRN to delete</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID to delete</option>
      </optgroup>

      <transport method="delete" path="grn" />
   </command>

   <command name="update_grn">
      Update a GRN.
      <optgroup name="update_grn_required" mandatory="true" fields="any">
         <option name="grn" type="string" conflicts="eon_id">GRN to update</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID to update</option>
      </optgroup>

      <optgroup name="update_grn_optional" mandatory="false" fields="any">
         <option name="disabled" type="boolean">GRN is disabled and cannot be mapped to new systems</option>
	 <option name="rename_to" type="string">Rename GRN</option>
      </optgroup>

      <transport method="post" path="grn" />
   </command>

   <command name="show_grn">
      Display a GRN.
      <optgroup name="update_grn_required" mandatory="true" fields="any">
         <option name="grn" type="string">GRN to display</option>
         <option name="eon_id" type="int">Numeric EON ID to display</option>
         <option name="all" type="flag">Show all GRNs</option>
      </optgroup>

      <transport method="get" path="grn" />
   </command>

   <command name="refresh_grns">
      Refresh the mapping from GRNs to EON IDs.
      <transport method="post" path="grn/command/refresh"/>
   </command>

   <command name="map_grn">
      Map a given GRN to a host or a personality. The affected host(s) must be
      recompiled for the changes to take effect.
      <optgroup name="map_grn_grn" mandatory="true" fields="any">
         <option name="grn" type="string" conflicts="eon_id">GRN as string</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID</option>
      </optgroup>
      <optgroup name="map_grn_target" mandatory="true" fields="any">
         <option name="hostname" type="string" conflicts="list personality">Host</option>
         <option name="list" type="list" conflicts="hostname personality">List of hosts</option>
         <option name="personality" type="string" conflicts="hostname list">Personality</option>
      </optgroup>
      <optgroup name="map_grn_optional" mandatory="false" fields="any">
         <option name="archetype" type="string">Archetype of the personality</option>
      </optgroup>

      <transport method="post" path="grn/command/map"/>
   </command>

   <command name="unmap_grn">
      Unmap a given GRN from a host or a personality. The affected host(s) must be
      recompiled for the changes to take effect.
      <optgroup name="unmap_grn_grn" mandatory="true" fields="any">
         <option name="grn" type="string" conflicts="eon_id">GRN as string</option>
         <option name="eon_id" type="int" conflicts="grn">Numeric EON ID</option>
      </optgroup>
      <optgroup name="unmap_grn_target" mandatory="true" fields="any">
         <option name="hostname" type="string" conflicts="list personality">Host</option>
         <option name="list" type="list" conflicts="hostname personality">List of hosts</option>
         <option name="personality" type="string" conflicts="hostname list">Personality</option>
      </optgroup>
      <optgroup name="unmap_grn_optional" mandatory="false" fields="any">
         <option name="archetype" type="string">Archetype of the personality</option>
      </optgroup>

      <transport method="post" path="grn/command/unmap"/>
   </command>

   <command name="add_resourcegroup">
      Add a new resource group.
      <optgroup name="add_rg_opts" mandatory="True" fields="all">
         <option name="resourcegroup" type="string">Name of the resource group</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname to apply resource group</option>
         <option name="cluster" type="string">Cluster to apply resource group</option>
      </optgroup>
      <transport method="put" path="resource/resourcegroup/%(resourcegroup)s" />
   </command>

   <command name="del_resourcegroup">
      Delete a resource group.
      <optgroup name="del_rg_opts" mandatory="True" fields="all">
         <option name="resourcegroup" type="string">Name of the resource group</option>
      </optgroup>
      <optgroup name="resource_mapping_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">Hostname of the resource group</option>
         <option name="cluster" type="string">Cluster of the resource group</option>
      </optgroup>
      <transport method="delete" path="resource/resourcegroup/%(resourcegroup)s" />
   </command>

   <command name="show_resourcegroup">
      Show resource groups based on filtering for host/cluster association.
      <optgroup name="show_resource_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="hostname" type="string">hostname</option>
         <option name="resourcegroup" type="string">resource group name</option>
         <option name="all" type="flag">list all hardware</option>
      </optgroup>
      <transport method="get" trigger="resourcegroup" path="resource/resourcegroup/%(resourcegroup)s" />
      <transport method="get" path="find/resource/resourcegroup" />
   </command>

   <command name="add_feature">
      Add a new feature. A feature is a template under &lt;archetype&gt;/features which
      gets included by the plenaries.
      <optgroup name="add_feature_opts" mandatory="True" fields="all">
         <option name="feature" type="string">The name of the feature</option>
         <option name="type" type="string">Type of the feature: host, hardware or interface</option>
      </optgroup>
      <optgroup name="add_feature_optional" mandatory="False" fields="any">
         <option name="post_personality" type="flag">Call the feature after the personality</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>

      <transport method="put" path="feature/%(type)s/%(feature)s"/>
   </command>

   <command name="del_feature">
      Delete a feature.
      <optgroup name="del_feature_opts" mandatory="True" fields="all">
         <option name="feature" type="string">The name of the feature</option>
         <option name="type" type="string">Type of the feature: host, hardware or interface</option>
      </optgroup>

      <transport method="delete" path="feature/%(type)s/%(feature)s"/>
   </command>

   <command name="show_feature">
      Display a single feature or all features.
      <optgroup name="show_feature_opts" mandatory="True" fields="any">
         <optgroup name="name_type" mandatory="False" fields="all">
            <option name="feature" type="string" conflicts="all">The name of the feature</option>
            <option name="type" type="string" conflicts="all">The type of the feature</option>
         </optgroup>
         <option name="all" type="flag" conflicts="feature type">Show all features</option>
      </optgroup>

      <transport trigger="all" method="get" path="feature"/>
      <transport method="get" path="feature/%(type)s/%(feature)s"/>
   </command>

   <command name="bind_feature">
      Bind a feature to a given object.
      <p/>
      Affected host plenaries will be refreshed unless the --noflush option has been specified.
      The hosts however are not compiled; that has to be done manually.
      <p/>
      Changing feature links for a whole archetype require --justification and a valid TCM.

      <optgroup name="bind_feature_opts" mandatory="True" fields="all">
         <option name="feature" type="string">Name of the feature</option>
         <optgroup name="target" mandatory="True" fields="any">
            <option name="personality" type="string">Name of a personality</option>
            <option name="archetype" type="string">Archetype</option>
            <option name="model" type="string">Name of a hardware model</option>
            <option name="interface" type="string">Interface of a machine</option>
         </optgroup>
      </optgroup>
      <optgroup name="bind_feature_optional" mandatory="False" fields="any">
         <option name="vendor" type="string">Vendor name, if the model name is not unique</option>
         <option name="justification" type="string">Extra authorization tokens (e.g. TCM number) to validate the request</option>
         <option name="flush" type="boolean" default="True">Enable flushing the affected host plenaries</option>
      </optgroup>

      <transport method="post" path="commands/bind_feature"/>
   </command>

   <command name="unbind_feature">
      Unbind a feature from a given object.
      <p/>
      Affected host plenaries will be refreshed unless the --noflush option has been specified.
      The hosts however are not compiled; that has to be done manually.
      <p/>
      Changing feature links for a whole archetype require --justification and a valid TCM.

      <optgroup name="unbind_feature_opts" mandatory="True" fields="all">
         <option name="feature" type="string">Name of the feature</option>
         <optgroup name="target" mandatory="True" fields="any">
            <option name="personality" type="string">Name of a personality</option>
            <option name="archetype" type="string">Archetype</option>
            <option name="model" type="string">Name of a hardware model</option>
            <option name="interface" type="string">Interface of a machine</option>
         </optgroup>
      </optgroup>
      <optgroup name="unbind_feature_optional" mandatory="False" fields="any">
         <option name="vendor" type="string">Vendor name, if the model name is not unique</option>
         <option name="justification" type="string">Extra authorization tokens (e.g. TCM number) to validate the request</option>
         <option name="flush" type="boolean" default="True">Enable flushing the affected host plenaries</option>
      </optgroup>

      <transport method="post" path="commands/unbind_feature"/>
   </command>

</commandline>
